["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/xregexp/lib/xregexp.js"],"~:js","shadow$provide.module$node_modules$xregexp$lib$xregexp=function(global$jscomp$0,require,module,exports){function _createForOfIteratorHelper(o,allowArrayLike){var it;if(\"undefined\"===typeof _symbol[\"default\"]||null==(0,_getIteratorMethod2[\"default\"])(o)){if((0,_isArray[\"default\"])(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&\"number\"===typeof o.length){it&&(o=it);var i=0;allowArrayLike=function(){};return{s:allowArrayLike,n:function(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},\ne:function(_e){throw _e;},f:allowArrayLike}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=!0,didErr=!1,err;return{s:function(){it=(0,_getIterator2[\"default\"])(o)},n:function(){var step=it.next();normalCompletion=step.done;return step},e:function(_e2){didErr=!0;err=_e2},f:function(){try{if(!normalCompletion&&null!=it[\"return\"])it[\"return\"]()}finally{if(didErr)throw err;\n}}}}function _unsupportedIterableToArray(o,minLen){var _context9;if(o){if(\"string\"===typeof o)return _arrayLikeToArray(o,minLen);var n=(0,_slice[\"default\"])(_context9=Object.prototype.toString.call(o)).call(_context9,8,-1);\"Object\"===n&&o.constructor&&(n=o.constructor.name);if(\"Map\"===n||\"Set\"===n)return(0,_from[\"default\"])(o);if(\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=\narr.length;for(var i=0,arr2=Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function hasNativeFlag(flag){var isSupported=!0;try{RegExp(\"\",flag),\"y\"===flag&&\"..\"===\".a\".replace(/a/gy,\".\")&&(isSupported=!1)}catch(exception){isSupported=!1}return isSupported}function augment(regex,captureNames,xSource,xFlags,isInternalOnly){var _context;regex.xregexp={captureNames};if(isInternalOnly)return regex;if(regex.__proto__)regex.__proto__=XRegExp.prototype;else for(var p in XRegExp.prototype)regex[p]=XRegExp.prototype[p];\nregex.xregexp.source=xSource;regex.xregexp.flags=xFlags?(0,_sort[\"default\"])(_context=xFlags.split(\"\")).call(_context).join(\"\"):xFlags;return regex}function clipDuplicates(str){return nativ.replace.call(str,/([\\s\\S])(?=[\\s\\S]*\\1)/g,\"\")}function copyRegex(regex,options){var _context2;if(!XRegExp.isRegExp(regex))throw new TypeError(\"Type RegExp expected\");var xData=regex.xregexp||{};var flags=regex;flags=hasFlagsProp?(0,_flags[\"default\"])(flags):nativ.exec.call(/\\/([a-z]*)$/i,RegExp.prototype.toString.call(flags))[1];\nvar flagsToAdd=\"\",flagsToRemove=\"\",xregexpSource=null,xregexpFlags=null;options=options||{};options.removeG&&(flagsToRemove+=\"g\");options.removeY&&(flagsToRemove+=\"y\");flagsToRemove&&(flags=nativ.replace.call(flags,new RegExp(\"[\".concat(flagsToRemove,\"]+\"),\"g\"),\"\"));options.addG&&(flagsToAdd+=\"g\");options.addY&&(flagsToAdd+=\"y\");flagsToAdd&&(flags=clipDuplicates(flags+flagsToAdd));options.isInternalOnly||(void 0!==xData.source&&(xregexpSource=xData.source),null!=(0,_flags[\"default\"])(xData)&&(xregexpFlags=\nflagsToAdd?clipDuplicates((0,_flags[\"default\"])(xData)+flagsToAdd):(0,_flags[\"default\"])(xData)));return regex=augment(new RegExp(options.source||regex.source,flags),regex.xregexp&&regex.xregexp.captureNames?(0,_slice[\"default\"])(_context2=xData.captureNames).call(_context2,0):null,xregexpSource,xregexpFlags,options.isInternalOnly)}function dec(hex){return(0,_parseInt2[\"default\"])(hex,16)}function getContextualTokenSeparator(match,scope,flags){(scope=\"(\"===match.input[match.index-1]||\")\"===match.input[match.index+\nmatch[0].length]||\"|\"===match.input[match.index-1]||\"|\"===match.input[match.index+match[0].length]||1>match.index||match.index+match[0].length>=match.input.length||nativ.test.call(/^\\(\\?[:=!]/,match.input.substr(match.index-3,3)))||(scope=match.input,match=match.index+match[0].length,scope=nativ.test.call((0,_includes[\"default\"])(flags).call(flags,\"x\")?/^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/:/^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/,(0,_slice[\"default\"])(scope).call(scope,match)));\nreturn scope?\"\":\"(?:)\"}function hex$jscomp$0(dec){return(0,_parseInt2[\"default\"])(dec,10).toString(16)}function isType(value,type){return toString.call(value)===\"[object \".concat(type,\"]\")}function pad4(str){for(;4>str.length;)str=\"0\".concat(str);return str}function prepareFlags(pattern,flags){if(clipDuplicates(flags)!==flags)throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));pattern=nativ.replace.call(pattern,/^\\(\\?([\\w$]+)\\)/,function($0,$1){if(nativ.test.call(/[gy]/,$1))throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\nflags=clipDuplicates(flags+$1);return\"\"});var _iterator=_createForOfIteratorHelper(flags),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var flag=_step.value;if(!registeredFlags[flag])throw new SyntaxError(\"Unknown regex flag \".concat(flag));}}catch(err){_iterator.e(err)}finally{_iterator.f()}return{pattern,flags}}function prepareOptions(value){var options={};return isType(value,\"String\")?((0,_forEach[\"default\"])(XRegExp).call(XRegExp,value,/[^\\s,]+/,function(match){options[match]=!0}),\noptions):value}function registerFlag(flag){if(!/^[\\w$]$/.test(flag))throw Error(\"Flag must be a single character A-Za-z0-9_$\");registeredFlags[flag]=!0}function toObject(value){if(null==value)throw new TypeError(\"Cannot convert null or undefined to object\");return value}function XRegExp(pattern$jscomp$0,flags$jscomp$0){if(XRegExp.isRegExp(pattern$jscomp$0)){if(void 0!==flags$jscomp$0)throw new TypeError(\"Cannot supply flags when copying a RegExp\");return copyRegex(pattern$jscomp$0)}pattern$jscomp$0=\nvoid 0===pattern$jscomp$0?\"\":String(pattern$jscomp$0);flags$jscomp$0=void 0===flags$jscomp$0?\"\":String(flags$jscomp$0);XRegExp.isInstalled(\"astral\")&&!(0,_includes[\"default\"])(flags$jscomp$0).call(flags$jscomp$0,\"A\")&&(flags$jscomp$0+=\"A\");patternCache[pattern$jscomp$0]||(patternCache[pattern$jscomp$0]={});if(!patternCache[pattern$jscomp$0][flags$jscomp$0]){var context={hasNamedCapture:!1,captureNames:[]},scope=\"default\",output=\"\",pos=0,applied=prepareFlags(pattern$jscomp$0,flags$jscomp$0),appliedPattern=\napplied.pattern;for(applied=(0,_flags[\"default\"])(applied);pos<appliedPattern.length;){do{for(var match,pattern=appliedPattern,flags=applied,pos$jscomp$0=pos,scope$jscomp$0=scope,context$jscomp$0=context,i=tokens.length,leadChar=pattern[pos$jscomp$0],result=null;i--;){var result$jscomp$0=tokens[i];if(!(result$jscomp$0.leadChar&&result$jscomp$0.leadChar!==leadChar||result$jscomp$0.scope!==scope$jscomp$0&&\"all\"!==result$jscomp$0.scope||result$jscomp$0.flag&&!(0,_includes[\"default\"])(flags).call(flags,\nresult$jscomp$0.flag))&&(match=XRegExp.exec(pattern,result$jscomp$0.regex,pos$jscomp$0,\"sticky\"))){result={matchLength:match[0].length,output:result$jscomp$0.handler.call(context$jscomp$0,match,scope$jscomp$0,flags),reparse:result$jscomp$0.reparse};break}}(result$jscomp$0=result)&&result$jscomp$0.reparse&&(appliedPattern=(0,_slice[\"default\"])(appliedPattern).call(appliedPattern,0,pos)+result$jscomp$0.output+(0,_slice[\"default\"])(appliedPattern).call(appliedPattern,pos+result$jscomp$0.matchLength))}while(result$jscomp$0&&\nresult$jscomp$0.reparse);result$jscomp$0?(output+=result$jscomp$0.output,pos+=result$jscomp$0.matchLength||1):(result$jscomp$0=XRegExp.exec(appliedPattern,nativeTokens[scope],pos,\"sticky\"),result$jscomp$0=(0,_slicedToArray2[\"default\"])(result$jscomp$0,1)[0],output+=result$jscomp$0,pos+=result$jscomp$0.length,\"[\"===result$jscomp$0&&\"default\"===scope?scope=\"class\":\"]\"===result$jscomp$0&&\"class\"===scope&&(scope=\"default\"))}patternCache[pattern$jscomp$0][flags$jscomp$0]={pattern:nativ.replace.call(output,\n/(?:\\(\\?:\\))+/g,\"(?:)\"),flags:nativ.replace.call(applied,/[^gimuy]+/g,\"\"),captures:context.hasNamedCapture?context.captureNames:null}}context=patternCache[pattern$jscomp$0][flags$jscomp$0];return augment(new RegExp(context.pattern,(0,_flags[\"default\"])(context)),context.captures,pattern$jscomp$0,flags$jscomp$0)}global$jscomp$0=require(\"module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault\");require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property\")(exports,\n\"__esModule\",{value:!0});exports[\"default\"]=void 0;var _getIterator2=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js$get_iterator\")),_isArray=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$array$is_array\")),_getIteratorMethod2=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js$get_iterator_method\")),_symbol=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$symbol\")),_from=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$array$from\")),\n_concat=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat\")),_indexOf=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$index_of\")),_create=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$object$create\")),_slicedToArray2=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$helpers$slicedToArray\")),_forEach=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$for_each\")),\n_includes=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes\")),_parseInt2=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$parse_int\")),_slice=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice\")),_sort=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$sort\")),_flags=global$jscomp$0(require(\"module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$flags\")),\nfeatures={astral:!1,namespacing:!1},nativ={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},fixed={},regexCache={},patternCache={},tokens=[],nativeTokens={\"default\":/\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\"class\":/\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/},\nreplacementToken=/\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g,correctExecNpcg=void 0===nativ.exec.call(/()??/,\"\")[1],hasFlagsProp=void 0!==(0,_flags[\"default\"])(/x/),toString={}.toString,hasNativeU=hasNativeFlag(\"u\"),hasNativeY=hasNativeFlag(\"y\"),registeredFlags={g:!0,i:!0,m:!0,u:hasNativeU,y:hasNativeY};XRegExp.prototype=/(?:)/;XRegExp.version=\"4.4.1\";XRegExp._clipDuplicates=clipDuplicates;XRegExp._hasNativeFlag=hasNativeFlag;XRegExp._dec=dec;XRegExp._hex=hex$jscomp$0;XRegExp._pad4=pad4;XRegExp.addToken=\nfunction(regex,handler,options){options=options||{};var optionalFlags=options.optionalFlags;options.flag&&registerFlag(options.flag);if(optionalFlags){optionalFlags=nativ.split.call(optionalFlags,\"\");optionalFlags=_createForOfIteratorHelper(optionalFlags);var _step2;try{for(optionalFlags.s();!(_step2=optionalFlags.n()).done;)registerFlag(_step2.value)}catch(err){optionalFlags.e(err)}finally{optionalFlags.f()}}tokens.push({regex:copyRegex(regex,{addG:!0,addY:hasNativeY,isInternalOnly:!0}),handler,\nscope:options.scope||\"default\",flag:options.flag,reparse:options.reparse,leadChar:options.leadChar});XRegExp.cache.flush(\"patterns\")};XRegExp.cache=function(pattern,flags){regexCache[pattern]||(regexCache[pattern]={});return regexCache[pattern][flags]||(regexCache[pattern][flags]=XRegExp(pattern,flags))};XRegExp.cache.flush=function(cacheName){\"patterns\"===cacheName?patternCache={}:regexCache={}};XRegExp.escape=function(str){return nativ.replace.call(toObject(str),/[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g,\"\\\\$\\x26\")};\nXRegExp.exec=function(str,regex,pos,sticky){var cacheKey=\"g\",addY,fakeY=!1;(addY=hasNativeY&&!!(sticky||regex.sticky&&!1!==sticky))?cacheKey+=\"y\":sticky&&(fakeY=!0,cacheKey+=\"FakeY\");regex.xregexp=regex.xregexp||{};sticky=regex.xregexp[cacheKey]||(regex.xregexp[cacheKey]=copyRegex(regex,{addG:!0,addY,source:fakeY?\"\".concat(regex.source,\"|()\"):void 0,removeY:!1===sticky,isInternalOnly:!0}));sticky.lastIndex=pos||0;str=fixed.exec.call(sticky,str);fakeY&&str&&\"\"===str.pop()&&(str=null);regex.global&&\n(regex.lastIndex=str?sticky.lastIndex:0);return str};XRegExp.forEach=function(str,regex,callback){for(var pos=0,i=-1;pos=XRegExp.exec(str,regex,pos);)callback(pos,++i,str,regex),pos=pos.index+(pos[0].length||1)};XRegExp.globalize=function(regex){return copyRegex(regex,{addG:!0})};XRegExp.install=function(options){options=prepareOptions(options);!features.astral&&options.astral&&(features.astral=!0);!features.namespacing&&options.namespacing&&(features.namespacing=!0)};XRegExp.isInstalled=function(feature){return!!features[feature]};\nXRegExp.isRegExp=function(value){return\"[object RegExp]\"===toString.call(value)};XRegExp.match=function(str,regex,scope){var global=regex.global&&\"one\"!==scope||\"all\"===scope,cacheKey=(global?\"g\":\"\")+(regex.sticky?\"y\":\"\")||\"noGY\";regex.xregexp=regex.xregexp||{};cacheKey=regex.xregexp[cacheKey]||(regex.xregexp[cacheKey]=copyRegex(regex,{addG:!!global,removeG:\"one\"===scope,isInternalOnly:!0}));str=nativ.match.call(toObject(str),cacheKey);regex.global&&(regex.lastIndex=\"one\"===scope&&str?str.index+str[0].length:\n0);return global?str||[]:str&&str[0]};XRegExp.matchChain=function(str,chain){return function recurseChain(values,level){function addMatch(match){if(item.backref){var ERR_UNDEFINED_GROUP=\"Backreference to undefined group: \".concat(item.backref),isNamedBackref=isNaN(item.backref);if(isNamedBackref&&XRegExp.isInstalled(\"namespacing\")){if(!(item.backref in match.groups))throw new ReferenceError(ERR_UNDEFINED_GROUP);}else if(!match.hasOwnProperty(item.backref))throw new ReferenceError(ERR_UNDEFINED_GROUP);\nmatch=isNamedBackref&&XRegExp.isInstalled(\"namespacing\")?match.groups[item.backref]:match[item.backref];matches.push(match||\"\")}else matches.push(match[0])}var item=chain[level].regex?chain[level]:{regex:chain[level]},matches=[];values=_createForOfIteratorHelper(values);var _step3;try{for(values.s();!(_step3=values.n()).done;){var value=_step3.value;(0,_forEach[\"default\"])(XRegExp).call(XRegExp,value,item.regex,addMatch)}}catch(err){values.e(err)}finally{values.f()}return level!==chain.length-1&&\nmatches.length?recurseChain(matches,level+1):matches}([str],0)};XRegExp.replace=function(str,search,replacement,scope){var isRegex=XRegExp.isRegExp(search),global=search.global&&\"one\"!==scope||\"all\"===scope,cacheKey=(global?\"g\":\"\")+(search.sticky?\"y\":\"\")||\"noGY\",s2=search;isRegex?(search.xregexp=search.xregexp||{},s2=search.xregexp[cacheKey]||(search.xregexp[cacheKey]=copyRegex(search,{addG:!!global,removeG:\"one\"===scope,isInternalOnly:!0}))):global&&(s2=new RegExp(XRegExp.escape(String(search)),\n\"g\"));str=fixed.replace.call(toObject(str),s2,replacement);isRegex&&search.global&&(search.lastIndex=0);return str};XRegExp.replaceEach=function(str,replacements){replacements=_createForOfIteratorHelper(replacements);var _step4;try{for(replacements.s();!(_step4=replacements.n()).done;){var r=_step4.value;str=XRegExp.replace(str,r[0],r[1],r[2])}}catch(err){replacements.e(err)}finally{replacements.f()}return str};XRegExp.split=function(str,separator,limit){return fixed.split.call(toObject(str),separator,\nlimit)};XRegExp.test=function(str,regex,pos,sticky){return!!XRegExp.exec(str,regex,pos,sticky)};XRegExp.uninstall=function(options){options=prepareOptions(options);features.astral&&options.astral&&(features.astral=!1);features.namespacing&&options.namespacing&&(features.namespacing=!1)};XRegExp.union=function(patterns,flags,options){function rewrite(match,paren,backref){var name=captureNames[numCaptures-numPriorCaptures];if(paren){if(++numCaptures,name)return\"(?\\x3c\".concat(name,\"\\x3e\")}else if(backref)return\"\\\\\".concat(+backref+\nnumPriorCaptures);return match}options=options||{};options=options.conjunction||\"or\";var numCaptures=0;if(!isType(patterns,\"Array\")||!patterns.length)throw new TypeError(\"Must provide a nonempty array of patterns to merge\");var parts=/(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g,output=[];patterns=_createForOfIteratorHelper(patterns);var _step5;try{for(patterns.s();!(_step5=patterns.n()).done;){var pattern=_step5.value;if(XRegExp.isRegExp(pattern)){var numPriorCaptures=numCaptures;\nvar captureNames=pattern.xregexp&&pattern.xregexp.captureNames||[];output.push(nativ.replace.call(XRegExp(pattern.source).source,parts,rewrite))}else output.push(XRegExp.escape(pattern))}}catch(err){patterns.e(err)}finally{patterns.f()}return XRegExp(output.join(\"none\"===options?\"\":\"|\"),flags)};fixed.exec=function(str){var origLastIndex=this.lastIndex,match=nativ.exec.apply(this,arguments);if(match){if(!correctExecNpcg&&1<match.length&&(0,_includes[\"default\"])(match).call(match,\"\")){var _context3,\nr2=copyRegex(this,{removeG:!0,isInternalOnly:!0});nativ.replace.call((0,_slice[\"default\"])(_context3=String(str)).call(_context3,match.index),r2,function(){for(var len=arguments.length,i=1;i<len-2;++i)void 0===(0>i||arguments.length<=i?void 0:arguments[i])&&(match[i]=void 0)})}_context3=match;XRegExp.isInstalled(\"namespacing\")&&(match.groups=(0,_create[\"default\"])(null),_context3=match.groups);if(this.xregexp&&this.xregexp.captureNames)for(r2=1;r2<match.length;++r2){var name=this.xregexp.captureNames[r2-\n1];name&&(_context3[name]=match[r2])}this.global&&!match[0].length&&this.lastIndex>match.index&&(this.lastIndex=match.index)}this.global||(this.lastIndex=origLastIndex);return match};fixed.test=function(str){return!!fixed.exec.call(this,str)};fixed.match=function(regex){if(!XRegExp.isRegExp(regex))regex=new RegExp(regex);else if(regex.global){var result=nativ.match.apply(this,arguments);regex.lastIndex=0;return result}return fixed.exec.call(regex,toObject(this))};fixed.replace=function(search,replacement){var isRegex=\nXRegExp.isRegExp(search);if(isRegex){if(search.xregexp)var captureNames=search.xregexp.captureNames;var origLastIndex=search.lastIndex}else search+=\"\";var result=isType(replacement,\"Function\")?nativ.replace.call(String(this),search,function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];if(captureNames)for(XRegExp.isInstalled(\"namespacing\")?(_len=(0,_create[\"default\"])(null),args.push(_len)):(args[0]=new String(args[0]),_len=args[0]),_key=0;_key<\ncaptureNames.length;++_key)captureNames[_key]&&(_len[captureNames[_key]]=args[_key+1]);return replacement.apply(void 0,args)}):nativ.replace.call(null==this?this:String(this),search,function(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return nativ.replace.call(String(replacement),replacementToken,function($0,bracketed,angled,dollarToken){if(bracketed=bracketed||angled){angled=+bracketed;if(angled<=args.length-3)return args[angled]||\"\";\nangled=captureNames?(0,_indexOf[\"default\"])(captureNames).call(captureNames,bracketed):-1;if(0>angled)throw new SyntaxError(\"Backreference to undefined group \".concat($0));return args[angled+1]||\"\"}if(\"$\"===dollarToken)return\"$\";if(\"\\x26\"===dollarToken||0===+dollarToken)return args[0];if(\"`\"===dollarToken){var _context4;return(0,_slice[\"default\"])(_context4=args[args.length-1]).call(_context4,0,args[args.length-2])}if(\"'\"===dollarToken){var _context5;return(0,_slice[\"default\"])(_context5=args[args.length-\n1]).call(_context5,args[args.length-2]+args[0].length)}dollarToken=+dollarToken;if(!isNaN(dollarToken)){if(dollarToken>args.length-3)throw new SyntaxError(\"Backreference to undefined group \".concat($0));return args[dollarToken]||\"\"}throw new SyntaxError(\"Invalid token \".concat($0));})});isRegex&&(search.lastIndex=search.global?0:origLastIndex);return result};fixed.split=function(separator,limit){if(!XRegExp.isRegExp(separator))return nativ.split.apply(this,arguments);var str=String(this),output=[],\norigLastIndex=separator.lastIndex,lastLastIndex=0,lastLength;limit=(void 0===limit?-1:limit)>>>0;(0,_forEach[\"default\"])(XRegExp).call(XRegExp,str,separator,function(match){match.index+match[0].length>lastLastIndex&&(output.push((0,_slice[\"default\"])(str).call(str,lastLastIndex,match.index)),1<match.length&&match.index<str.length&&Array.prototype.push.apply(output,(0,_slice[\"default\"])(match).call(match,1)),lastLength=match[0].length,lastLastIndex=match.index+lastLength)});lastLastIndex===str.length?\n(!nativ.test.call(separator,\"\")||lastLength)&&output.push(\"\"):output.push((0,_slice[\"default\"])(str).call(str,lastLastIndex));separator.lastIndex=origLastIndex;return output.length>limit?(0,_slice[\"default\"])(output).call(output,0,limit):output};XRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/,function(match,scope){if(\"B\"===match[1]&&\"default\"===scope)return match[0];throw new SyntaxError(\"Invalid escape \".concat(match[0]));},{scope:\"all\",\nleadChar:\"\\\\\"});XRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/,function(match,scope,flags){scope=dec(match[1]);if(1114111<scope)throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));if(65535>=scope)return\"\\\\u\".concat(pad4(hex$jscomp$0(scope)));if(hasNativeU&&(0,_includes[\"default\"])(flags).call(flags,\"u\"))return match[0];throw new SyntaxError(\"Cannot use Unicode code point above \\\\u{FFFF} without flag u\");},{scope:\"all\",leadChar:\"\\\\\"});XRegExp.addToken(/\\[(\\^?)\\]/,function(match){return match[1]?\n\"[\\\\s\\\\S]\":\"\\\\b\\\\B\"},{leadChar:\"[\"});XRegExp.addToken(/\\(\\?#[^)]*\\)/,getContextualTokenSeparator,{leadChar:\"(\"});XRegExp.addToken(/\\s+|#[^\\n]*\\n?/,getContextualTokenSeparator,{flag:\"x\"});XRegExp.addToken(/\\./,function(){return\"[\\\\s\\\\S]\"},{flag:\"s\",leadChar:\".\"});XRegExp.addToken(/\\\\k<([\\w$]+)>/,function(match){var _context6,_context7,index=isNaN(match[1])?(0,_indexOf[\"default\"])(_context6=this.captureNames).call(_context6,match[1])+1:+match[1];_context6=match.index+match[0].length;if(!index||index>\nthis.captureNames.length)throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));return(0,_concat[\"default\"])(_context7=\"\\\\\".concat(index)).call(_context7,_context6===match.input.length||isNaN(match.input[_context6])?\"\":\"(?:)\")},{leadChar:\"\\\\\"});XRegExp.addToken(/\\\\(\\d+)/,function(match,scope){if(!(\"default\"===scope&&/^[1-9]/.test(match[1])&&+match[1]<=this.captureNames.length)&&\"0\"!==match[1])throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\nreturn match[0]},{scope:\"all\",leadChar:\"\\\\\"});XRegExp.addToken(/\\(\\?P?<([\\w$]+)>/,function(match){var _context8;if(!isNaN(match[1]))throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));if(!XRegExp.isInstalled(\"namespacing\")&&(\"length\"===match[1]||\"__proto__\"===match[1]))throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));if((0,_includes[\"default\"])(_context8=this.captureNames).call(_context8,match[1]))throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\nthis.captureNames.push(match[1]);this.hasNamedCapture=!0;return\"(\"},{leadChar:\"(\"});XRegExp.addToken(/\\((?!\\?)/,function(match,scope,flags){if((0,_includes[\"default\"])(flags).call(flags,\"n\"))return\"(?:\";this.captureNames.push(null);return\"(\"},{optionalFlags:\"n\",leadChar:\"(\"});exports[\"default\"]=XRegExp;module.exports=exports.default}","~:source","shadow$provide[\"module$node_modules$xregexp$lib$xregexp\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _getIteratorMethod2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator-method\"));\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol\"));\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/from\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _parseInt2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/parse-int\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\n\nvar _flags = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/flags\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\"default\"] === \"undefined\" || (0, _getIteratorMethod2[\"default\"])(o) == null) { if ((0, _isArray[\"default\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\"default\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { var _context9; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\"default\"])(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return (0, _from[\"default\"])(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*!\n * XRegExp 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2007-present MIT License\n */\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\n\nvar features = {\n  astral: false,\n  namespacing: false\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\n\nvar nativ = {\n  exec: RegExp.prototype.exec,\n  test: RegExp.prototype.test,\n  match: String.prototype.match,\n  replace: String.prototype.replace,\n  split: String.prototype.split\n}; // Storage for fixed/extended native methods\n\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\n\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\n\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n\nvar tokens = []; // Token scopes\n\nvar defaultScope = 'default';\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\n\nvar nativeTokens = {\n  // Any native multicharacter token in default scope, or any single character\n  'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n  // Any native multicharacter token in character class scope, or any single character\n  'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n}; // Any backreference or dollar-prefixed character in replacement strings\n\nvar replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\n\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\n\nvar hasFlagsProp = (0, _flags[\"default\"])(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\n\nvar _ref = {},\n    toString = _ref.toString;\n\nfunction hasNativeFlag(flag) {\n  // Can't check based on the presence of properties/getters since browsers might support such\n  // properties even when they don't support the corresponding flag in regex construction (tested\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n  // throws an error)\n  var isSupported = true;\n\n  try {\n    // Can't use regex literals for testing even in a `try` because regex literals with\n    // unsupported flags cause a compilation error in IE\n    new RegExp('', flag); // Work around a broken/incomplete IE11 polyfill for sticky introduced in core-js 3.6.0\n\n    if (flag === 'y') {\n      // Using function to avoid babel transform to regex literal\n      var gy = function () {\n        return 'gy';\n      }();\n\n      var incompleteY = '.a'.replace(new RegExp('a', gy), '.') === '..';\n\n      if (incompleteY) {\n        isSupported = false;\n      }\n    }\n  } catch (exception) {\n    isSupported = false;\n  }\n\n  return isSupported;\n} // Check for ES6 `u` flag support\n\n\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\n\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\n\nvar registeredFlags = {\n  g: true,\n  i: true,\n  m: true,\n  u: hasNativeU,\n  y: hasNativeY\n};\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {!RegExp} Augmented regex.\n */\n\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n  var _context;\n\n  regex[REGEX_DATA] = {\n    captureNames: captureNames\n  };\n\n  if (isInternalOnly) {\n    return regex;\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n\n\n  if (regex.__proto__) {\n    regex.__proto__ = XRegExp.prototype;\n  } else {\n    for (var p in XRegExp.prototype) {\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n      // extensions exist on `regex.prototype` anyway\n      regex[p] = XRegExp.prototype[p];\n    }\n  }\n\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort[\"default\"])(_context = xFlags.split('')).call(_context).join('') : xFlags;\n  return regex;\n}\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {string} String with any duplicate characters removed.\n */\n\n\nfunction clipDuplicates(str) {\n  return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\n\n\nfunction copyRegex(regex, options) {\n  var _context2;\n\n  if (!XRegExp.isRegExp(regex)) {\n    throw new TypeError('Type RegExp expected');\n  }\n\n  var xData = regex[REGEX_DATA] || {};\n  var flags = getNativeFlags(regex);\n  var flagsToAdd = '';\n  var flagsToRemove = '';\n  var xregexpSource = null;\n  var xregexpFlags = null;\n  options = options || {};\n\n  if (options.removeG) {\n    flagsToRemove += 'g';\n  }\n\n  if (options.removeY) {\n    flagsToRemove += 'y';\n  }\n\n  if (flagsToRemove) {\n    flags = nativ.replace.call(flags, new RegExp(\"[\".concat(flagsToRemove, \"]+\"), 'g'), '');\n  }\n\n  if (options.addG) {\n    flagsToAdd += 'g';\n  }\n\n  if (options.addY) {\n    flagsToAdd += 'y';\n  }\n\n  if (flagsToAdd) {\n    flags = clipDuplicates(flags + flagsToAdd);\n  }\n\n  if (!options.isInternalOnly) {\n    if (xData.source !== undefined) {\n      xregexpSource = xData.source;\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\n    // that indicates we're not tracking original precompilation flags\n\n\n    if ((0, _flags[\"default\"])(xData) != null) {\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n      // removed for non-internal regexes, so don't need to handle it\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags[\"default\"])(xData) + flagsToAdd) : (0, _flags[\"default\"])(xData);\n    }\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n  // translation to native regex syntax\n\n\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice[\"default\"])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\n  return regex;\n}\n/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {number}\n */\n\n\nfunction dec(hex) {\n  return (0, _parseInt2[\"default\"])(hex, 16);\n}\n/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {string} Either '' or '(?:)', depending on which is needed in the context of the match.\n */\n\n\nfunction getContextualTokenSeparator(match, scope, flags) {\n  if ( // No need to separate tokens if at the beginning or end of a group\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n  // The way this is written relies on:\n  // - The search regex matching only 3-char strings.\n  // - Although `substr` gives chars from the end of the string if given a negative index,\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n  nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\n    return '';\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n  // error `(? :` into `(?:`.\n\n\n  return '(?:)';\n}\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {string} Native flags in use.\n */\n\n\nfunction getNativeFlags(regex) {\n  return hasFlagsProp ? (0, _flags[\"default\"])(regex) : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n  // with an empty string) allows this to continue working predictably when\n  // `XRegExp.proptotype.toString` is overridden\n  nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {boolean} Whether the regex uses named capture.\n */\n\n\nfunction hasNamedCapture(regex) {\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {string}\n */\n\n\nfunction hex(dec) {\n  return (0, _parseInt2[\"default\"])(dec, 10).toString(16);\n}\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */\n\n\nfunction isQuantifierNext(pattern, pos, flags) {\n  var inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n  var lineCommentPattern = '#[^#\\\\n]*';\n  var quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n  return nativ.test.call((0, _includes[\"default\"])(flags).call(flags, 'x') ? // Ignore any leading whitespace, line comments, and inline comments\n  /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ : // Ignore any leading inline comments\n  /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/, (0, _slice[\"default\"])(pattern).call(pattern, pos));\n}\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {boolean} Whether the object matches the type.\n */\n\n\nfunction isType(value, type) {\n  return toString.call(value) === \"[object \".concat(type, \"]\");\n}\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {string}\n */\n\n\nfunction pad4(str) {\n  while (str.length < 4) {\n    str = \"0\".concat(str);\n  }\n\n  return str;\n}\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {!Object} Object with properties `pattern` and `flags`.\n */\n\n\nfunction prepareFlags(pattern, flags) {\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n  if (clipDuplicates(flags) !== flags) {\n    throw new SyntaxError(\"Invalid duplicate regex flag \".concat(flags));\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\n\n\n  pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function ($0, $1) {\n    if (nativ.test.call(/[gy]/, $1)) {\n      throw new SyntaxError(\"Cannot use flag g or y in mode modifier \".concat($0));\n    } // Allow duplicate flags within the mode modifier\n\n\n    flags = clipDuplicates(flags + $1);\n    return '';\n  }); // Throw on unknown native or nonnative flags\n\n  var _iterator = _createForOfIteratorHelper(flags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var flag = _step.value;\n\n      if (!registeredFlags[flag]) {\n        throw new SyntaxError(\"Unknown regex flag \".concat(flag));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    pattern: pattern,\n    flags: flags\n  };\n}\n/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\n\n\nfunction prepareOptions(value) {\n  var options = {};\n\n  if (isType(value, 'String')) {\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, value, /[^\\s,]+/, function (match) {\n      options[match] = true;\n    });\n    return options;\n  }\n\n  return value;\n}\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */\n\n\nfunction registerFlag(flag) {\n  if (!/^[\\w$]$/.test(flag)) {\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\n  }\n\n  registeredFlags[flag] = true;\n}\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\n\n\nfunction runTokens(pattern, flags, pos, scope, context) {\n  var i = tokens.length;\n  var leadChar = pattern[pos];\n  var result = null;\n  var match;\n  var t; // Run in reverse insertion order\n\n  while (i--) {\n    t = tokens[i];\n\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes[\"default\"])(flags).call(flags, t.flag)) {\n      continue;\n    }\n\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n\n    if (match) {\n      result = {\n        matchLength: match[0].length,\n        output: t.handler.call(context, match, scope, flags),\n        reparse: t.reparse\n      }; // Finished with token tests\n\n      break;\n    }\n  }\n\n  return result;\n}\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setAstral(on) {\n  features.astral = on;\n}\n/**\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\n * https://github.com/tc39/proposal-regexp-named-groups\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\n\n\nfunction setNamespacing(on) {\n  features.namespacing = on;\n}\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\n\n\nfunction toObject(value) {\n  // null or undefined\n  if (value == null) {\n    throw new TypeError('Cannot convert null or undefined to object');\n  }\n\n  return value;\n} // ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\n\n\nfunction XRegExp(pattern, flags) {\n  if (XRegExp.isRegExp(pattern)) {\n    if (flags !== undefined) {\n      throw new TypeError('Cannot supply flags when copying a RegExp');\n    }\n\n    return copyRegex(pattern);\n  } // Copy the argument behavior of `RegExp`\n\n\n  pattern = pattern === undefined ? '' : String(pattern);\n  flags = flags === undefined ? '' : String(flags);\n\n  if (XRegExp.isInstalled('astral') && !(0, _includes[\"default\"])(flags).call(flags, 'A')) {\n    // This causes an error to be thrown if the Unicode Base addon is not available\n    flags += 'A';\n  }\n\n  if (!patternCache[pattern]) {\n    patternCache[pattern] = {};\n  }\n\n  if (!patternCache[pattern][flags]) {\n    var context = {\n      hasNamedCapture: false,\n      captureNames: []\n    };\n    var scope = defaultScope;\n    var output = '';\n    var pos = 0;\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n\n    var applied = prepareFlags(pattern, flags);\n    var appliedPattern = applied.pattern;\n    var appliedFlags = (0, _flags[\"default\"])(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n\n    while (pos < appliedPattern.length) {\n      do {\n        // Check for custom tokens at the current position\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\n        // pattern before running tokens again at the same position\n\n        if (result && result.reparse) {\n          appliedPattern = (0, _slice[\"default\"])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice[\"default\"])(appliedPattern).call(appliedPattern, pos + result.matchLength);\n        }\n      } while (result && result.reparse);\n\n      if (result) {\n        output += result.output;\n        pos += result.matchLength || 1;\n      } else {\n        // Get the native token at the current position\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\n            _XRegExp$exec2 = (0, _slicedToArray2[\"default\"])(_XRegExp$exec, 1),\n            token = _XRegExp$exec2[0];\n\n        output += token;\n        pos += token.length;\n\n        if (token === '[' && scope === defaultScope) {\n          scope = classScope;\n        } else if (token === ']' && scope === classScope) {\n          scope = defaultScope;\n        }\n      }\n    }\n\n    patternCache[pattern][flags] = {\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\n      // separated. However, more than one empty group in a row is never needed.\n      pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n      // Strip all but native flags\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n      // `context.captureNames` has an item for each capturing group, even if unnamed\n      captures: context.hasNamedCapture ? context.captureNames : null\n    };\n  }\n\n  var generated = patternCache[pattern][flags];\n  return augment(new RegExp(generated.pattern, (0, _flags[\"default\"])(generated)), generated.captures, pattern, flags);\n} // Add `RegExp.prototype` to the prototype chain\n\n\nXRegExp.prototype = /(?:)/; // ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */\n\nXRegExp.version = '4.4.1'; // ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\n\nXRegExp._clipDuplicates = clipDuplicates;\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\n\nXRegExp.addToken = function (regex, handler, options) {\n  options = options || {};\n  var _options = options,\n      optionalFlags = _options.optionalFlags;\n\n  if (options.flag) {\n    registerFlag(options.flag);\n  }\n\n  if (optionalFlags) {\n    optionalFlags = nativ.split.call(optionalFlags, '');\n\n    var _iterator2 = _createForOfIteratorHelper(optionalFlags),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var flag = _step2.value;\n        registerFlag(flag);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } // Add to the private list of syntax tokens\n\n\n  tokens.push({\n    regex: copyRegex(regex, {\n      addG: true,\n      addY: hasNativeY,\n      isInternalOnly: true\n    }),\n    handler: handler,\n    scope: options.scope || defaultScope,\n    flag: options.flag,\n    reparse: options.reparse,\n    leadChar: options.leadChar\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n  // might now produce different results\n\n  XRegExp.cache.flush('patterns');\n};\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\n\n\nXRegExp.cache = function (pattern, flags) {\n  if (!regexCache[pattern]) {\n    regexCache[pattern] = {};\n  }\n\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\n}; // Intentionally undocumented; used in tests\n\n\nXRegExp.cache.flush = function (cacheName) {\n  if (cacheName === 'patterns') {\n    // Flush the pattern cache used by the `XRegExp` constructor\n    patternCache = {};\n  } else {\n    // Flush the regex cache populated by `XRegExp.cache`\n    regexCache = {};\n  }\n};\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {string} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\n\n\nXRegExp.escape = function (str) {\n  return nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\n\n\nXRegExp.exec = function (str, regex, pos, sticky) {\n  var cacheKey = 'g';\n  var addY = false;\n  var fakeY = false;\n  var match;\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\n\n  if (addY) {\n    cacheKey += 'y';\n  } else if (sticky) {\n    // Simulate sticky matching by appending an empty capture to the original regex. The\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n    // and will not search the rest of the subject string. We'll know that the original regex\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n    // capture participated in the match).\n    fakeY = true;\n    cacheKey += 'FakeY';\n  }\n\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: true,\n    addY: addY,\n    source: fakeY ? \"\".concat(regex.source, \"|()\") : undefined,\n    removeY: sticky === false,\n    isInternalOnly: true\n  }));\n  pos = pos || 0;\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n  // the original regexp failed (see above).\n\n  if (fakeY && match && match.pop() === '') {\n    match = null;\n  }\n\n  if (regex.global) {\n    regex.lastIndex = match ? r2.lastIndex : 0;\n  }\n\n  return match;\n};\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\n\n\nXRegExp.forEach = function (str, regex, callback) {\n  var pos = 0;\n  var i = -1;\n  var match;\n\n  while (match = XRegExp.exec(str, regex, pos)) {\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n    // which is a nice side effect that brings extra safety.\n    callback(match, ++i, str, regex);\n    pos = match.index + (match[0].length || 1);\n  }\n};\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\n\n\nXRegExp.globalize = function (regex) {\n  return copyRegex(regex, {\n    addG: true\n  });\n};\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // Adds named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral namespacing');\n */\n\n\nXRegExp.install = function (options) {\n  options = prepareOptions(options);\n\n  if (!features.astral && options.astral) {\n    setAstral(true);\n  }\n\n  if (!features.namespacing && options.namespacing) {\n    setNamespacing(true);\n  }\n};\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n *   - `namespacing`\n * @returns {boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\n\n\nXRegExp.isInstalled = function (feature) {\n  return !!features[feature];\n};\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\n\n\nXRegExp.isRegExp = function (value) {\n  return toString.call(value) === '[object RegExp]';\n}; // isType(value, 'RegExp');\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\n\n\nXRegExp.match = function (str, regex, scope) {\n  var global = regex.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\n\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n    addG: !!global,\n    removeG: scope === 'one',\n    isInternalOnly: true\n  }));\n  var result = nativ.match.call(toObject(str), r2);\n\n  if (regex.global) {\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n    result.index + result[0].length : 0;\n  }\n\n  return global ? result || [] : result && result[0];\n};\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\n\n\nXRegExp.matchChain = function (str, chain) {\n  return function recurseChain(values, level) {\n    var item = chain[level].regex ? chain[level] : {\n      regex: chain[level]\n    };\n    var matches = [];\n\n    function addMatch(match) {\n      if (item.backref) {\n        var ERR_UNDEFINED_GROUP = \"Backreference to undefined group: \".concat(item.backref);\n        var isNamedBackref = isNaN(item.backref);\n\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n          if (!(item.backref in match.groups)) {\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\n          }\n        } else if (!match.hasOwnProperty(item.backref)) {\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\n        }\n\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\n        matches.push(backrefValue || '');\n      } else {\n        matches.push(match[0]);\n      }\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(values),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var value = _step3.value;\n        (0, _forEach[\"default\"])(XRegExp).call(XRegExp, value, item.regex, addMatch);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\n  }([str], 0);\n};\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\n\n\nXRegExp.replace = function (str, search, replacement, scope) {\n  var isRegex = XRegExp.isRegExp(search);\n  var global = search.global && scope !== 'one' || scope === 'all';\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\n  var s2 = search;\n\n  if (isRegex) {\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n    // `lastIndex` isn't updated *during* replacement iterations\n\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\n      addG: !!global,\n      removeG: scope === 'one',\n      isInternalOnly: true\n    }));\n  } else if (global) {\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n  } // Fixed `replace` required for named backreferences, etc.\n\n\n  var result = fixed.replace.call(toObject(str), s2, replacement);\n\n  if (isRegex && search.global) {\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n    search.lastIndex = 0;\n  }\n\n  return result;\n};\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */\n\n\nXRegExp.replaceEach = function (str, replacements) {\n  var _iterator4 = _createForOfIteratorHelper(replacements),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var r = _step4.value;\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return str;\n};\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\n\n\nXRegExp.split = function (str, separator, limit) {\n  return fixed.split.call(toObject(str), separator, limit);\n};\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\n// Do this the easy way :-)\n\n\nXRegExp.test = function (str, regex, pos, sticky) {\n  return !!XRegExp.exec(str, regex, pos, sticky);\n};\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // Don't add named capture groups to the `groups` property of matches\n *   namespacing: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral namespacing');\n */\n\n\nXRegExp.uninstall = function (options) {\n  options = prepareOptions(options);\n\n  if (features.astral && options.astral) {\n    setAstral(false);\n  }\n\n  if (features.namespacing && options.namespacing) {\n    setNamespacing(false);\n  }\n};\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */\n\n\nXRegExp.union = function (patterns, flags, options) {\n  options = options || {};\n  var conjunction = options.conjunction || 'or';\n  var numCaptures = 0;\n  var numPriorCaptures;\n  var captureNames;\n\n  function rewrite(match, paren, backref) {\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\n\n    if (paren) {\n      ++numCaptures; // If the current capture has a name, preserve the name\n\n      if (name) {\n        return \"(?<\".concat(name, \">\");\n      } // Backreference\n\n    } else if (backref) {\n      // Rewrite the backreference\n      return \"\\\\\".concat(+backref + numPriorCaptures);\n    }\n\n    return match;\n  }\n\n  if (!(isType(patterns, 'Array') && patterns.length)) {\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\n  }\n\n  var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var output = [];\n\n  var _iterator5 = _createForOfIteratorHelper(patterns),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var pattern = _step5.value;\n\n      if (XRegExp.isRegExp(pattern)) {\n        numPriorCaptures = numCaptures;\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n        // independently valid; helps keep this simple. Named captures are put back\n\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n      } else {\n        output.push(XRegExp.escape(pattern));\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  var separator = conjunction === 'none' ? '' : '|';\n  return XRegExp(output.join(separator), flags);\n}; // ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\n\n\nfixed.exec = function (str) {\n  var origLastIndex = this.lastIndex;\n  var match = nativ.exec.apply(this, arguments);\n\n  if (match) {\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n    // in standards mode follows the spec.\n    if (!correctExecNpcg && match.length > 1 && (0, _includes[\"default\"])(match).call(match, '')) {\n      var _context3;\n\n      var r2 = copyRegex(this, {\n        removeG: true,\n        isInternalOnly: true\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n      // matching due to characters outside the match\n\n      nativ.replace.call((0, _slice[\"default\"])(_context3 = String(str)).call(_context3, match.index), r2, function () {\n        var len = arguments.length; // Skip index 0 and the last 2\n\n        for (var i = 1; i < len - 2; ++i) {\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\n            match[i] = undefined;\n          }\n        }\n      });\n    } // Attach named capture properties\n\n\n    var groupsObject = match;\n\n    if (XRegExp.isInstalled('namespacing')) {\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n      match.groups = (0, _create[\"default\"])(null);\n      groupsObject = match.groups;\n    }\n\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n      // Skip index 0\n      for (var i = 1; i < match.length; ++i) {\n        var name = this[REGEX_DATA].captureNames[i - 1];\n\n        if (name) {\n          groupsObject[name] = match[i];\n        }\n      }\n    } // Fix browsers that increment `lastIndex` after zero-length matches\n\n\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\n      this.lastIndex = match.index;\n    }\n  }\n\n  if (!this.global) {\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n    this.lastIndex = origLastIndex;\n  }\n\n  return match;\n};\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {boolean} Whether the regex matched the provided value.\n */\n\n\nfixed.test = function (str) {\n  // Do this the easy way :-)\n  return !!fixed.exec.call(this, str);\n};\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\n\n\nfixed.match = function (regex) {\n  if (!XRegExp.isRegExp(regex)) {\n    // Use the native `RegExp` rather than `XRegExp`\n    regex = new RegExp(regex);\n  } else if (regex.global) {\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\n\n    regex.lastIndex = 0;\n    return result;\n  }\n\n  return fixed.exec.call(regex, toObject(this));\n};\n/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {string} New string with one or all matches replaced.\n */\n\n\nfixed.replace = function (search, replacement) {\n  var isRegex = XRegExp.isRegExp(search);\n  var origLastIndex;\n  var captureNames;\n  var result;\n\n  if (isRegex) {\n    if (search[REGEX_DATA]) {\n      captureNames = search[REGEX_DATA].captureNames;\n    } // Only needed if `search` is nonglobal\n\n\n    origLastIndex = search.lastIndex;\n  } else {\n    search += ''; // Type-convert\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\n\n\n  if (isType(replacement, 'Function')) {\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n    // functions isn't type-converted to a string\n    result = nativ.replace.call(String(this), search, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (captureNames) {\n        var groupsObject;\n\n        if (XRegExp.isInstalled('namespacing')) {\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n          groupsObject = (0, _create[\"default\"])(null);\n          args.push(groupsObject);\n        } else {\n          // Change the `args[0]` string primitive to a `String` object that can store\n          // properties. This really does need to use `String` as a constructor\n          args[0] = new String(args[0]);\n          groupsObject = args[0];\n        } // Store named backreferences\n\n\n        for (var i = 0; i < captureNames.length; ++i) {\n          if (captureNames[i]) {\n            groupsObject[captureNames[i]] = args[i + 1];\n          }\n        }\n      } // ES6 specs the context for replacement functions as `undefined`\n\n\n      return replacement.apply(void 0, args);\n    });\n  } else {\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\n    // while still throwing on null or undefined context\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n      function replacer($0, bracketed, angled, dollarToken) {\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\n\n        if (bracketed) {\n          // XRegExp behavior for `${n}` or `$<n>`:\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n          //    entire match. Any number of leading zeros may be used.\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\n          //    overridden by numbered capture. In practice, this does not overlap with\n          //    numbered capture since XRegExp does not allow named capture to use a bare\n          //    integer as the name.\n          // 3. If the name or number does not refer to an existing capturing group, it's\n          //    an error.\n          var n = +bracketed; // Type-convert; drop leading zeros\n\n          if (n <= args.length - 3) {\n            return args[n] || '';\n          } // Groups with the same name is an error, else would need `lastIndexOf`\n\n\n          n = captureNames ? (0, _indexOf[\"default\"])(captureNames).call(captureNames, bracketed) : -1;\n\n          if (n < 0) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[n + 1] || '';\n        } // Else, special variable or numbered backreference without curly braces\n\n\n        if (dollarToken === '$') {\n          // $$\n          return '$';\n        }\n\n        if (dollarToken === '&' || +dollarToken === 0) {\n          // $&, $0 (not followed by 1-9), $00\n          return args[0];\n        }\n\n        if (dollarToken === '`') {\n          var _context4;\n\n          // $` (left context)\n          return (0, _slice[\"default\"])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\n        }\n\n        if (dollarToken === \"'\") {\n          var _context5;\n\n          // $' (right context)\n          return (0, _slice[\"default\"])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\n        } // Else, numbered backreference without braces\n\n\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\n        // XRegExp behavior for `$n` and `$nn`:\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n        // - `$1` is an error if no capturing groups.\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n        //   instead.\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\n        // Native behavior, for comparison:\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n        // - `$1` is a literal `$1` if no capturing groups.\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n        // - `$0` is a literal `$0`.\n\n        if (!isNaN(dollarToken)) {\n          if (dollarToken > args.length - 3) {\n            throw new SyntaxError(\"Backreference to undefined group \".concat($0));\n          }\n\n          return args[dollarToken] || '';\n        } // `$` followed by an unsupported char is an error, unlike native JS\n\n\n        throw new SyntaxError(\"Invalid token \".concat($0));\n      }\n    });\n  }\n\n  if (isRegex) {\n    if (search.global) {\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n      search.lastIndex = 0;\n    } else {\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n      search.lastIndex = origLastIndex;\n    }\n  }\n\n  return result;\n};\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {!Array} Array of substrings.\n */\n\n\nfixed.split = function (separator, limit) {\n  if (!XRegExp.isRegExp(separator)) {\n    // Browsers handle nonregex split correctly, so use the faster native method\n    return nativ.split.apply(this, arguments);\n  }\n\n  var str = String(this);\n  var output = [];\n  var origLastIndex = separator.lastIndex;\n  var lastLastIndex = 0;\n  var lastLength; // Values for `limit`, per the spec:\n  // If undefined: pow(2,32) - 1\n  // If 0, Infinity, or NaN: 0\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n  // If negative number: pow(2,32) - floor(abs(limit))\n  // If other: Type-convert, then use the above rules\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n\n  limit = (limit === undefined ? -1 : limit) >>> 0;\n  (0, _forEach[\"default\"])(XRegExp).call(XRegExp, str, separator, function (match) {\n    // This condition is not the same as `if (match[0].length)`\n    if (match.index + match[0].length > lastLastIndex) {\n      output.push((0, _slice[\"default\"])(str).call(str, lastLastIndex, match.index));\n\n      if (match.length > 1 && match.index < str.length) {\n        Array.prototype.push.apply(output, (0, _slice[\"default\"])(match).call(match, 1));\n      }\n\n      lastLength = match[0].length;\n      lastLastIndex = match.index + lastLength;\n    }\n  });\n\n  if (lastLastIndex === str.length) {\n    if (!nativ.test.call(separator, '') || lastLength) {\n      output.push('');\n    }\n  } else {\n    output.push((0, _slice[\"default\"])(str).call(str, lastLastIndex));\n  }\n\n  separator.lastIndex = origLastIndex;\n  return output.length > limit ? (0, _slice[\"default\"])(output).call(output, 0, limit) : output;\n}; // ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\n\n\nXRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/, function (match, scope) {\n  // \\B is allowed in default scope only\n  if (match[1] === 'B' && scope === defaultScope) {\n    return match[0];\n  }\n\n  throw new SyntaxError(\"Invalid escape \".concat(match[0]));\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\n\nXRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/, function (match, scope, flags) {\n  var code = dec(match[1]);\n\n  if (code > 0x10FFFF) {\n    throw new SyntaxError(\"Invalid Unicode code point \".concat(match[0]));\n  }\n\n  if (code <= 0xFFFF) {\n    // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n    // separate from preceding tokens\n    return \"\\\\u\".concat(pad4(hex(code)));\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n\n\n  if (hasNativeU && (0, _includes[\"default\"])(flags).call(flags, 'u')) {\n    return match[0];\n  }\n\n  throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\n\nXRegExp.addToken(/\\[(\\^?)\\]/, // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n\n/* eslint-disable no-confusing-arrow */\nfunction (match) {\n  return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n},\n/* eslint-enable no-confusing-arrow */\n{\n  leadChar: '['\n});\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\n\nXRegExp.addToken(/\\(\\?#[^)]*\\)/, getContextualTokenSeparator, {\n  leadChar: '('\n});\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\n\nXRegExp.addToken(/\\s+|#[^\\n]*\\n?/, getContextualTokenSeparator, {\n  flag: 'x'\n});\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\n\nXRegExp.addToken(/\\./, function () {\n  return '[\\\\s\\\\S]';\n}, {\n  flag: 's',\n  leadChar: '.'\n});\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\n\nXRegExp.addToken(/\\\\k<([\\w$]+)>/, function (match) {\n  var _context6, _context7;\n\n  // Groups with the same name is an error, else would need `lastIndexOf`\n  var index = isNaN(match[1]) ? (0, _indexOf[\"default\"])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\n  var endIndex = match.index + match[0].length;\n\n  if (!index || index > this.captureNames.length) {\n    throw new SyntaxError(\"Backreference to undefined group \".concat(match[0]));\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n  // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n\n\n  return (0, _concat[\"default\"])(_context7 = \"\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\n}, {\n  leadChar: '\\\\'\n});\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\n\nXRegExp.addToken(/\\\\(\\d+)/, function (match, scope) {\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\n    throw new SyntaxError(\"Cannot use octal escape or backreference to undefined group \".concat(match[0]));\n  }\n\n  return match[0];\n}, {\n  scope: 'all',\n  leadChar: '\\\\'\n});\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\n\nXRegExp.addToken(/\\(\\?P?<([\\w$]+)>/, function (match) {\n  var _context8;\n\n  // Disallow bare integers as names because named backreferences are added to match arrays\n  // and therefore numeric properties may lead to incorrect lookups\n  if (!isNaN(match[1])) {\n    throw new SyntaxError(\"Cannot use integer as capture name \".concat(match[0]));\n  }\n\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n    throw new SyntaxError(\"Cannot use reserved word as capture name \".concat(match[0]));\n  }\n\n  if ((0, _includes[\"default\"])(_context8 = this.captureNames).call(_context8, match[1])) {\n    throw new SyntaxError(\"Cannot use same name for multiple groups \".concat(match[0]));\n  }\n\n  this.captureNames.push(match[1]);\n  this.hasNamedCapture = true;\n  return '(';\n}, {\n  leadChar: '('\n});\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\n\nXRegExp.addToken(/\\((?!\\?)/, function (match, scope, flags) {\n  if ((0, _includes[\"default\"])(flags).call(flags, 'n')) {\n    return '(?:';\n  }\n\n  this.captureNames.push(null);\n  return '(';\n}, {\n  optionalFlags: 'n',\n  leadChar: '('\n});\nvar _default = XRegExp;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$flags","~$module$node_modules$$babel$runtime_corejs3$core_js$get_iterator_method","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$index_of","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$for_each","~$module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$sort","~$shadow.js","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$array$from","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$object$create","~$module$node_modules$$babel$runtime_corejs3$core_js$get_iterator","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$symbol","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice","~$module$node_modules$$babel$runtime_corejs3$helpers$slicedToArray","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$parse_int","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$array$is_array"]],"~:properties",["^5",["n","replaceEach","leadChar","handler","_hasNativeFlag","s","forEach","output","f","e","namespacing","removeY","prototype","addToken","captures","astral","union","optionalFlags","_pad4","regex","lastIndex","flush","flags","globalize","hasNamedCapture","exec","cache","escape","replace","addG","value","uninstall","isInternalOnly","install","split","_hex","scope","addY","i","source","pattern","y","removeG","match","version","__proto__","g","u","_dec","_clipDuplicates","matchLength","isInstalled","reparse","isRegExp","m","captureNames","done","groups","flag","matchChain","test"]],"~:compiled-at",1626505495784,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$xregexp$lib$xregexp.js\",\n\"lineCount\":46,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/xregexp/lib/xregexp.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$xregexp$lib$xregexp\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime-corejs3/helpers/interopRequireDefault\\\");\\n\\nvar _Object$defineProperty = require(\\\"@babel/runtime-corejs3/core-js-stable/object/define-property\\\");\\n\\n_Object$defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _getIterator2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js/get-iterator\\\"));\\n\\nvar _isArray = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/array/is-array\\\"));\\n\\nvar _getIteratorMethod2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js/get-iterator-method\\\"));\\n\\nvar _symbol = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/symbol\\\"));\\n\\nvar _from = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/array/from\\\"));\\n\\nvar _concat = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/concat\\\"));\\n\\nvar _indexOf = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/index-of\\\"));\\n\\nvar _create = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/object/create\\\"));\\n\\nvar _slicedToArray2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/helpers/slicedToArray\\\"));\\n\\nvar _forEach = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/for-each\\\"));\\n\\nvar _includes = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/includes\\\"));\\n\\nvar _parseInt2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/parse-int\\\"));\\n\\nvar _slice = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/slice\\\"));\\n\\nvar _sort = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/sort\\\"));\\n\\nvar _flags = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/flags\\\"));\\n\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\\\"default\\\"] === \\\"undefined\\\" || (0, _getIteratorMethod2[\\\"default\\\"])(o) == null) { if ((0, _isArray[\\\"default\\\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\"number\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\\\"default\\\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { var _context9; if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\\\"default\\\"])(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return (0, _from[\\\"default\\\"])(o); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\n/*!\\n * XRegExp 4.4.1\\n * <xregexp.com>\\n * Steven Levithan (c) 2007-present MIT License\\n */\\n\\n/**\\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\\n * make your client-side grepping simpler and more powerful, while freeing you from related\\n * cross-browser inconsistencies.\\n */\\n// ==--------------------------==\\n// Private stuff\\n// ==--------------------------==\\n// Property name used for extended regex instance data\\nvar REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled\\n\\nvar features = {\\n  astral: false,\\n  namespacing: false\\n}; // Native methods to use and restore ('native' is an ES3 reserved keyword)\\n\\nvar nativ = {\\n  exec: RegExp.prototype.exec,\\n  test: RegExp.prototype.test,\\n  match: String.prototype.match,\\n  replace: String.prototype.replace,\\n  split: String.prototype.split\\n}; // Storage for fixed/extended native methods\\n\\nvar fixed = {}; // Storage for regexes cached by `XRegExp.cache`\\n\\nvar regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor\\n\\nvar patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\\n\\nvar tokens = []; // Token scopes\\n\\nvar defaultScope = 'default';\\nvar classScope = 'class'; // Regexes that match native regex syntax, including octals\\n\\nvar nativeTokens = {\\n  // Any native multicharacter token in default scope, or any single character\\n  'default': /\\\\\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\\\d*|x[\\\\dA-Fa-f]{2}|u(?:[\\\\dA-Fa-f]{4}|{[\\\\dA-Fa-f]+})|c[A-Za-z]|[\\\\s\\\\S])|\\\\(\\\\?(?:[:=!]|<[=!])|[?*+]\\\\?|{\\\\d+(?:,\\\\d*)?}\\\\??|[\\\\s\\\\S]/,\\n  // Any native multicharacter token in character class scope, or any single character\\n  'class': /\\\\\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\\\dA-Fa-f]{2}|u(?:[\\\\dA-Fa-f]{4}|{[\\\\dA-Fa-f]+})|c[A-Za-z]|[\\\\s\\\\S])|[\\\\s\\\\S]/\\n}; // Any backreference or dollar-prefixed character in replacement strings\\n\\nvar replacementToken = /\\\\$(?:{([\\\\w$]+)}|<([\\\\w$]+)>|(\\\\d\\\\d?|[\\\\s\\\\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups\\n\\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support\\n\\nvar hasFlagsProp = (0, _flags[\\\"default\\\"])(/x/) !== undefined; // Shortcut to `Object.prototype.toString`\\n\\nvar _ref = {},\\n    toString = _ref.toString;\\n\\nfunction hasNativeFlag(flag) {\\n  // Can't check based on the presence of properties/getters since browsers might support such\\n  // properties even when they don't support the corresponding flag in regex construction (tested\\n  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\\n  // throws an error)\\n  var isSupported = true;\\n\\n  try {\\n    // Can't use regex literals for testing even in a `try` because regex literals with\\n    // unsupported flags cause a compilation error in IE\\n    new RegExp('', flag); // Work around a broken/incomplete IE11 polyfill for sticky introduced in core-js 3.6.0\\n\\n    if (flag === 'y') {\\n      // Using function to avoid babel transform to regex literal\\n      var gy = function () {\\n        return 'gy';\\n      }();\\n\\n      var incompleteY = '.a'.replace(new RegExp('a', gy), '.') === '..';\\n\\n      if (incompleteY) {\\n        isSupported = false;\\n      }\\n    }\\n  } catch (exception) {\\n    isSupported = false;\\n  }\\n\\n  return isSupported;\\n} // Check for ES6 `u` flag support\\n\\n\\nvar hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support\\n\\nvar hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags\\n\\nvar registeredFlags = {\\n  g: true,\\n  i: true,\\n  m: true,\\n  u: hasNativeU,\\n  y: hasNativeY\\n};\\n/**\\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\\n *\\n * @private\\n * @param {RegExp} regex Regex to augment.\\n * @param {Array} captureNames Array with capture names, or `null`.\\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\\n *   skipping some operations like attaching `XRegExp.prototype` properties.\\n * @returns {!RegExp} Augmented regex.\\n */\\n\\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\\n  var _context;\\n\\n  regex[REGEX_DATA] = {\\n    captureNames: captureNames\\n  };\\n\\n  if (isInternalOnly) {\\n    return regex;\\n  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\\n\\n\\n  if (regex.__proto__) {\\n    regex.__proto__ = XRegExp.prototype;\\n  } else {\\n    for (var p in XRegExp.prototype) {\\n      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\\n      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\\n      // extensions exist on `regex.prototype` anyway\\n      regex[p] = XRegExp.prototype[p];\\n    }\\n  }\\n\\n  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\\n\\n  regex[REGEX_DATA].flags = xFlags ? (0, _sort[\\\"default\\\"])(_context = xFlags.split('')).call(_context).join('') : xFlags;\\n  return regex;\\n}\\n/**\\n * Removes any duplicate characters from the provided string.\\n *\\n * @private\\n * @param {String} str String to remove duplicate characters from.\\n * @returns {string} String with any duplicate characters removed.\\n */\\n\\n\\nfunction clipDuplicates(str) {\\n  return nativ.replace.call(str, /([\\\\s\\\\S])(?=[\\\\s\\\\S]*\\\\1)/g, '');\\n}\\n/**\\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\\n * flags g and y while copying the regex.\\n *\\n * @private\\n * @param {RegExp} regex Regex to copy.\\n * @param {Object} [options] Options object with optional properties:\\n *   - `addG` {Boolean} Add flag g while copying the regex.\\n *   - `addY` {Boolean} Add flag y while copying the regex.\\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\\n *     skipping some operations like attaching `XRegExp.prototype` properties.\\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\\n */\\n\\n\\nfunction copyRegex(regex, options) {\\n  var _context2;\\n\\n  if (!XRegExp.isRegExp(regex)) {\\n    throw new TypeError('Type RegExp expected');\\n  }\\n\\n  var xData = regex[REGEX_DATA] || {};\\n  var flags = getNativeFlags(regex);\\n  var flagsToAdd = '';\\n  var flagsToRemove = '';\\n  var xregexpSource = null;\\n  var xregexpFlags = null;\\n  options = options || {};\\n\\n  if (options.removeG) {\\n    flagsToRemove += 'g';\\n  }\\n\\n  if (options.removeY) {\\n    flagsToRemove += 'y';\\n  }\\n\\n  if (flagsToRemove) {\\n    flags = nativ.replace.call(flags, new RegExp(\\\"[\\\".concat(flagsToRemove, \\\"]+\\\"), 'g'), '');\\n  }\\n\\n  if (options.addG) {\\n    flagsToAdd += 'g';\\n  }\\n\\n  if (options.addY) {\\n    flagsToAdd += 'y';\\n  }\\n\\n  if (flagsToAdd) {\\n    flags = clipDuplicates(flags + flagsToAdd);\\n  }\\n\\n  if (!options.isInternalOnly) {\\n    if (xData.source !== undefined) {\\n      xregexpSource = xData.source;\\n    } // null or undefined; don't want to add to `flags` if the previous value was null, since\\n    // that indicates we're not tracking original precompilation flags\\n\\n\\n    if ((0, _flags[\\\"default\\\"])(xData) != null) {\\n      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\\n      // removed for non-internal regexes, so don't need to handle it\\n      xregexpFlags = flagsToAdd ? clipDuplicates((0, _flags[\\\"default\\\"])(xData) + flagsToAdd) : (0, _flags[\\\"default\\\"])(xData);\\n    }\\n  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\\n  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\\n  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\\n  // translation to native regex syntax\\n\\n\\n  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? (0, _slice[\\\"default\\\"])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);\\n  return regex;\\n}\\n/**\\n * Converts hexadecimal to decimal.\\n *\\n * @private\\n * @param {String} hex\\n * @returns {number}\\n */\\n\\n\\nfunction dec(hex) {\\n  return (0, _parseInt2[\\\"default\\\"])(hex, 16);\\n}\\n/**\\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\\n * inline comment or whitespace with flag x. This is used directly as a token handler function\\n * passed to `XRegExp.addToken`.\\n *\\n * @private\\n * @param {String} match Match arg of `XRegExp.addToken` handler\\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\\n * @returns {string} Either '' or '(?:)', depending on which is needed in the context of the match.\\n */\\n\\n\\nfunction getContextualTokenSeparator(match, scope, flags) {\\n  if ( // No need to separate tokens if at the beginning or end of a group\\n  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`\\n  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern\\n  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\\n  // The way this is written relies on:\\n  // - The search regex matching only 3-char strings.\\n  // - Although `substr` gives chars from the end of the string if given a negative index,\\n  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\\n  nativ.test.call(/^\\\\(\\\\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier\\n  isQuantifierNext(match.input, match.index + match[0].length, flags)) {\\n    return '';\\n  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\\\\1 1` or `\\\\1(?#)1` to `\\\\11`.\\n  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\\n  // error `(? :` into `(?:`.\\n\\n\\n  return '(?:)';\\n}\\n/**\\n * Returns native `RegExp` flags used by a regex object.\\n *\\n * @private\\n * @param {RegExp} regex Regex to check.\\n * @returns {string} Native flags in use.\\n */\\n\\n\\nfunction getNativeFlags(regex) {\\n  return hasFlagsProp ? (0, _flags[\\\"default\\\"])(regex) : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\\n  // with an empty string) allows this to continue working predictably when\\n  // `XRegExp.proptotype.toString` is overridden\\n  nativ.exec.call(/\\\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\\n}\\n/**\\n * Determines whether a regex has extended instance data used to track capture names.\\n *\\n * @private\\n * @param {RegExp} regex Regex to check.\\n * @returns {boolean} Whether the regex uses named capture.\\n */\\n\\n\\nfunction hasNamedCapture(regex) {\\n  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\\n}\\n/**\\n * Converts decimal to hexadecimal.\\n *\\n * @private\\n * @param {Number|String} dec\\n * @returns {string}\\n */\\n\\n\\nfunction hex(dec) {\\n  return (0, _parseInt2[\\\"default\\\"])(dec, 10).toString(16);\\n}\\n/**\\n * Checks whether the next nonignorable token after the specified position is a quantifier.\\n *\\n * @private\\n * @param {String} pattern Pattern to search within.\\n * @param {Number} pos Index in `pattern` to search at.\\n * @param {String} flags Flags used by the pattern.\\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\\n */\\n\\n\\nfunction isQuantifierNext(pattern, pos, flags) {\\n  var inlineCommentPattern = '\\\\\\\\(\\\\\\\\?#[^)]*\\\\\\\\)';\\n  var lineCommentPattern = '#[^#\\\\\\\\n]*';\\n  var quantifierPattern = '[?*+]|{\\\\\\\\d+(?:,\\\\\\\\d*)?}';\\n  return nativ.test.call((0, _includes[\\\"default\\\"])(flags).call(flags, 'x') ? // Ignore any leading whitespace, line comments, and inline comments\\n  /^(?:\\\\s|#[^#\\\\n]*|\\\\(\\\\?#[^)]*\\\\))*(?:[?*+]|{\\\\d+(?:,\\\\d*)?})/ : // Ignore any leading inline comments\\n  /^(?:\\\\(\\\\?#[^)]*\\\\))*(?:[?*+]|{\\\\d+(?:,\\\\d*)?})/, (0, _slice[\\\"default\\\"])(pattern).call(pattern, pos));\\n}\\n/**\\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\\n *\\n * @private\\n * @param {*} value Object to check.\\n * @param {String} type Type to check for, in TitleCase.\\n * @returns {boolean} Whether the object matches the type.\\n */\\n\\n\\nfunction isType(value, type) {\\n  return toString.call(value) === \\\"[object \\\".concat(type, \\\"]\\\");\\n}\\n/**\\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\\n *\\n * @private\\n * @param {String} str\\n * @returns {string}\\n */\\n\\n\\nfunction pad4(str) {\\n  while (str.length < 4) {\\n    str = \\\"0\\\".concat(str);\\n  }\\n\\n  return str;\\n}\\n/**\\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\\n * the flag preparation logic from the `XRegExp` constructor.\\n *\\n * @private\\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\\n * @param {String} flags Any combination of flags.\\n * @returns {!Object} Object with properties `pattern` and `flags`.\\n */\\n\\n\\nfunction prepareFlags(pattern, flags) {\\n  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\\n  if (clipDuplicates(flags) !== flags) {\\n    throw new SyntaxError(\\\"Invalid duplicate regex flag \\\".concat(flags));\\n  } // Strip and apply a leading mode modifier with any combination of flags except g or y\\n\\n\\n  pattern = nativ.replace.call(pattern, /^\\\\(\\\\?([\\\\w$]+)\\\\)/, function ($0, $1) {\\n    if (nativ.test.call(/[gy]/, $1)) {\\n      throw new SyntaxError(\\\"Cannot use flag g or y in mode modifier \\\".concat($0));\\n    } // Allow duplicate flags within the mode modifier\\n\\n\\n    flags = clipDuplicates(flags + $1);\\n    return '';\\n  }); // Throw on unknown native or nonnative flags\\n\\n  var _iterator = _createForOfIteratorHelper(flags),\\n      _step;\\n\\n  try {\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n      var flag = _step.value;\\n\\n      if (!registeredFlags[flag]) {\\n        throw new SyntaxError(\\\"Unknown regex flag \\\".concat(flag));\\n      }\\n    }\\n  } catch (err) {\\n    _iterator.e(err);\\n  } finally {\\n    _iterator.f();\\n  }\\n\\n  return {\\n    pattern: pattern,\\n    flags: flags\\n  };\\n}\\n/**\\n * Prepares an options object from the given value.\\n *\\n * @private\\n * @param {String|Object} value Value to convert to an options object.\\n * @returns {Object} Options object.\\n */\\n\\n\\nfunction prepareOptions(value) {\\n  var options = {};\\n\\n  if (isType(value, 'String')) {\\n    (0, _forEach[\\\"default\\\"])(XRegExp).call(XRegExp, value, /[^\\\\s,]+/, function (match) {\\n      options[match] = true;\\n    });\\n    return options;\\n  }\\n\\n  return value;\\n}\\n/**\\n * Registers a flag so it doesn't throw an 'unknown flag' error.\\n *\\n * @private\\n * @param {String} flag Single-character flag to register.\\n */\\n\\n\\nfunction registerFlag(flag) {\\n  if (!/^[\\\\w$]$/.test(flag)) {\\n    throw new Error('Flag must be a single character A-Za-z0-9_$');\\n  }\\n\\n  registeredFlags[flag] = true;\\n}\\n/**\\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\\n * position, until a match is found.\\n *\\n * @private\\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\\n * @param {String} flags Flags being used to construct the regex.\\n * @param {Number} pos Position to search for tokens within `pattern`.\\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\\n * @param {Object} context Context object to use for token handler functions.\\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\\n */\\n\\n\\nfunction runTokens(pattern, flags, pos, scope, context) {\\n  var i = tokens.length;\\n  var leadChar = pattern[pos];\\n  var result = null;\\n  var match;\\n  var t; // Run in reverse insertion order\\n\\n  while (i--) {\\n    t = tokens[i];\\n\\n    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(0, _includes[\\\"default\\\"])(flags).call(flags, t.flag)) {\\n      continue;\\n    }\\n\\n    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\\n\\n    if (match) {\\n      result = {\\n        matchLength: match[0].length,\\n        output: t.handler.call(context, match, scope, flags),\\n        reparse: t.reparse\\n      }; // Finished with token tests\\n\\n      break;\\n    }\\n  }\\n\\n  return result;\\n}\\n/**\\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\\n * the Unicode Base addon is not available, since flag A is registered by that addon.\\n *\\n * @private\\n * @param {Boolean} on `true` to enable; `false` to disable.\\n */\\n\\n\\nfunction setAstral(on) {\\n  features.astral = on;\\n}\\n/**\\n * Adds named capture groups to the `groups` property of match arrays. See here for details:\\n * https://github.com/tc39/proposal-regexp-named-groups\\n *\\n * @private\\n * @param {Boolean} on `true` to enable; `false` to disable.\\n */\\n\\n\\nfunction setNamespacing(on) {\\n  features.namespacing = on;\\n}\\n/**\\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\\n * the ES5 abstract operation `ToObject`.\\n *\\n * @private\\n * @param {*} value Object to check and return.\\n * @returns {*} The provided object.\\n */\\n\\n\\nfunction toObject(value) {\\n  // null or undefined\\n  if (value == null) {\\n    throw new TypeError('Cannot convert null or undefined to object');\\n  }\\n\\n  return value;\\n} // ==--------------------------==\\n// Constructor\\n// ==--------------------------==\\n\\n/**\\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\\n * native regular expression in that additional syntax and flags are supported. The returned object\\n * is in fact a native `RegExp` and works with all native methods.\\n *\\n * @class XRegExp\\n * @constructor\\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\\n * @param {String} [flags] Any combination of flags.\\n *   Native flags:\\n *     - `g` - global\\n *     - `i` - ignore case\\n *     - `m` - multiline anchors\\n *     - `u` - unicode (ES6)\\n *     - `y` - sticky (Firefox 3+, ES6)\\n *   Additional XRegExp flags:\\n *     - `n` - explicit capture\\n *     - `s` - dot matches all (aka singleline)\\n *     - `x` - free-spacing and line comments (aka extended)\\n *     - `A` - astral (requires the Unicode Base addon)\\n *   Flags cannot be provided when constructing one `RegExp` from another.\\n * @returns {RegExp} Extended regular expression object.\\n * @example\\n *\\n * // With named capture and flag x\\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\\n *          (?<month> [0-9]{2} ) -?  # month\\n *          (?<day>   [0-9]{2} )     # day`, 'x');\\n *\\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\\n * // have fresh `lastIndex` properties (set to zero).\\n * XRegExp(/regex/);\\n */\\n\\n\\nfunction XRegExp(pattern, flags) {\\n  if (XRegExp.isRegExp(pattern)) {\\n    if (flags !== undefined) {\\n      throw new TypeError('Cannot supply flags when copying a RegExp');\\n    }\\n\\n    return copyRegex(pattern);\\n  } // Copy the argument behavior of `RegExp`\\n\\n\\n  pattern = pattern === undefined ? '' : String(pattern);\\n  flags = flags === undefined ? '' : String(flags);\\n\\n  if (XRegExp.isInstalled('astral') && !(0, _includes[\\\"default\\\"])(flags).call(flags, 'A')) {\\n    // This causes an error to be thrown if the Unicode Base addon is not available\\n    flags += 'A';\\n  }\\n\\n  if (!patternCache[pattern]) {\\n    patternCache[pattern] = {};\\n  }\\n\\n  if (!patternCache[pattern][flags]) {\\n    var context = {\\n      hasNamedCapture: false,\\n      captureNames: []\\n    };\\n    var scope = defaultScope;\\n    var output = '';\\n    var pos = 0;\\n    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier\\n\\n    var applied = prepareFlags(pattern, flags);\\n    var appliedPattern = applied.pattern;\\n    var appliedFlags = (0, _flags[\\\"default\\\"])(applied); // Use XRegExp's tokens to translate the pattern to a native regex pattern.\\n    // `appliedPattern.length` may change on each iteration if tokens use `reparse`\\n\\n    while (pos < appliedPattern.length) {\\n      do {\\n        // Check for custom tokens at the current position\\n        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the\\n        // pattern before running tokens again at the same position\\n\\n        if (result && result.reparse) {\\n          appliedPattern = (0, _slice[\\\"default\\\"])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice[\\\"default\\\"])(appliedPattern).call(appliedPattern, pos + result.matchLength);\\n        }\\n      } while (result && result.reparse);\\n\\n      if (result) {\\n        output += result.output;\\n        pos += result.matchLength || 1;\\n      } else {\\n        // Get the native token at the current position\\n        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),\\n            _XRegExp$exec2 = (0, _slicedToArray2[\\\"default\\\"])(_XRegExp$exec, 1),\\n            token = _XRegExp$exec2[0];\\n\\n        output += token;\\n        pos += token.length;\\n\\n        if (token === '[' && scope === defaultScope) {\\n          scope = classScope;\\n        } else if (token === ']' && scope === classScope) {\\n          scope = defaultScope;\\n        }\\n      }\\n    }\\n\\n    patternCache[pattern][flags] = {\\n      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\\n      // groups are sometimes inserted during regex transpilation in order to keep tokens\\n      // separated. However, more than one empty group in a row is never needed.\\n      pattern: nativ.replace.call(output, /(?:\\\\(\\\\?:\\\\))+/g, '(?:)'),\\n      // Strip all but native flags\\n      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\\n      // `context.captureNames` has an item for each capturing group, even if unnamed\\n      captures: context.hasNamedCapture ? context.captureNames : null\\n    };\\n  }\\n\\n  var generated = patternCache[pattern][flags];\\n  return augment(new RegExp(generated.pattern, (0, _flags[\\\"default\\\"])(generated)), generated.captures, pattern, flags);\\n} // Add `RegExp.prototype` to the prototype chain\\n\\n\\nXRegExp.prototype = /(?:)/; // ==--------------------------==\\n// Public properties\\n// ==--------------------------==\\n\\n/**\\n * The XRegExp version number as a string containing three dot-separated parts. For example,\\n * '2.0.0-beta-3'.\\n *\\n * @static\\n * @memberOf XRegExp\\n * @type String\\n */\\n\\nXRegExp.version = '4.4.1'; // ==--------------------------==\\n// Public methods\\n// ==--------------------------==\\n// Intentionally undocumented; used in tests and addons\\n\\nXRegExp._clipDuplicates = clipDuplicates;\\nXRegExp._hasNativeFlag = hasNativeFlag;\\nXRegExp._dec = dec;\\nXRegExp._hex = hex;\\nXRegExp._pad4 = pad4;\\n/**\\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\\n *\\n * @memberOf XRegExp\\n * @param {RegExp} regex Regex object that matches the new token.\\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\\n *   properties of the regex being built, through `this`. Invoked with three arguments:\\n *   - The match array, with named backreference properties.\\n *   - The regex scope where the match was found: 'default' or 'class'.\\n *   - The flags used by the regex, including any flags in a leading mode modifier.\\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\\n *   construct XRegExps within the function or you will trigger infinite recursion.\\n * @param {Object} [options] Options object with optional properties:\\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\\n *     throwing an 'unknown flag' error when any of the flags are used.\\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\\n *     final, and instead be reparseable by other tokens (including the current token). Allows\\n *     token chaining or deferring.\\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\\n *     you provide an erroneous value. However, providing it can increase the token's performance\\n *     since the token can be skipped at any positions where this character doesn't appear.\\n * @example\\n *\\n * // Basic usage: Add \\\\a for the ALERT control code\\n * XRegExp.addToken(\\n *   /\\\\\\\\a/,\\n *   () => '\\\\\\\\x07',\\n *   {scope: 'all'}\\n * );\\n * XRegExp('\\\\\\\\a[\\\\\\\\a-\\\\\\\\n]+').test('\\\\x07\\\\n\\\\x07'); // -> true\\n *\\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\\n * // character classes only)\\n * XRegExp.addToken(\\n *   /([?*+]|{\\\\d+(?:,\\\\d*)?})(\\\\??)/,\\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\\n *   {flag: 'U'}\\n * );\\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\\n */\\n\\nXRegExp.addToken = function (regex, handler, options) {\\n  options = options || {};\\n  var _options = options,\\n      optionalFlags = _options.optionalFlags;\\n\\n  if (options.flag) {\\n    registerFlag(options.flag);\\n  }\\n\\n  if (optionalFlags) {\\n    optionalFlags = nativ.split.call(optionalFlags, '');\\n\\n    var _iterator2 = _createForOfIteratorHelper(optionalFlags),\\n        _step2;\\n\\n    try {\\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\n        var flag = _step2.value;\\n        registerFlag(flag);\\n      }\\n    } catch (err) {\\n      _iterator2.e(err);\\n    } finally {\\n      _iterator2.f();\\n    }\\n  } // Add to the private list of syntax tokens\\n\\n\\n  tokens.push({\\n    regex: copyRegex(regex, {\\n      addG: true,\\n      addY: hasNativeY,\\n      isInternalOnly: true\\n    }),\\n    handler: handler,\\n    scope: options.scope || defaultScope,\\n    flag: options.flag,\\n    reparse: options.reparse,\\n    leadChar: options.leadChar\\n  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\\n  // might now produce different results\\n\\n  XRegExp.cache.flush('patterns');\\n};\\n/**\\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\\n * the same pattern and flag combination, the cached copy of the regex is returned.\\n *\\n * @memberOf XRegExp\\n * @param {String} pattern Regex pattern string.\\n * @param {String} [flags] Any combination of XRegExp flags.\\n * @returns {RegExp} Cached XRegExp object.\\n * @example\\n *\\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\\n *   // The regex is compiled once only\\n * }\\n */\\n\\n\\nXRegExp.cache = function (pattern, flags) {\\n  if (!regexCache[pattern]) {\\n    regexCache[pattern] = {};\\n  }\\n\\n  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));\\n}; // Intentionally undocumented; used in tests\\n\\n\\nXRegExp.cache.flush = function (cacheName) {\\n  if (cacheName === 'patterns') {\\n    // Flush the pattern cache used by the `XRegExp` constructor\\n    patternCache = {};\\n  } else {\\n    // Flush the regex cache populated by `XRegExp.cache`\\n    regexCache = {};\\n  }\\n};\\n/**\\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\\n * can safely be used at any point within a regex that uses any flags.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to escape.\\n * @returns {string} String with regex metacharacters escaped.\\n * @example\\n *\\n * XRegExp.escape('Escaped? <.>');\\n * // -> 'Escaped\\\\?\\\\ <\\\\.>'\\n */\\n\\n\\nXRegExp.escape = function (str) {\\n  return nativ.replace.call(toObject(str), /[-\\\\[\\\\]{}()*+?.,\\\\\\\\^$|#\\\\s]/g, '\\\\\\\\$&');\\n};\\n/**\\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\\n * regex uses named capture, named backreference properties are included on the match array.\\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {RegExp} regex Regex to search with.\\n * @param {Number} [pos=0] Zero-based index at which to start the search.\\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\\n * @returns {Array} Match array with named backreference properties, or `null`.\\n * @example\\n *\\n * // Basic use, with named backreference\\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\\\\\+(?<hex>[0-9A-F]{4})'));\\n * match.hex; // -> '2620'\\n *\\n * // With pos and sticky, in a loop\\n * let pos = 2, result = [], match;\\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\\\d)>/, pos, 'sticky')) {\\n *   result.push(match[1]);\\n *   pos = match.index + match[0].length;\\n * }\\n * // result -> ['2', '3', '4']\\n */\\n\\n\\nXRegExp.exec = function (str, regex, pos, sticky) {\\n  var cacheKey = 'g';\\n  var addY = false;\\n  var fakeY = false;\\n  var match;\\n  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);\\n\\n  if (addY) {\\n    cacheKey += 'y';\\n  } else if (sticky) {\\n    // Simulate sticky matching by appending an empty capture to the original regex. The\\n    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\\n    // and will not search the rest of the subject string. We'll know that the original regex\\n    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\\n    // capture participated in the match).\\n    fakeY = true;\\n    cacheKey += 'FakeY';\\n  }\\n\\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`\\n\\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\\n    addG: true,\\n    addY: addY,\\n    source: fakeY ? \\\"\\\".concat(regex.source, \\\"|()\\\") : undefined,\\n    removeY: sticky === false,\\n    isInternalOnly: true\\n  }));\\n  pos = pos || 0;\\n  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\\n\\n  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\\n  // the original regexp failed (see above).\\n\\n  if (fakeY && match && match.pop() === '') {\\n    match = null;\\n  }\\n\\n  if (regex.global) {\\n    regex.lastIndex = match ? r2.lastIndex : 0;\\n  }\\n\\n  return match;\\n};\\n/**\\n * Executes a provided function once per regex match. Searches always start at the beginning of the\\n * string and continue until the end, regardless of the state of the regex's `global` property and\\n * initial `lastIndex`.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {RegExp} regex Regex to search with.\\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\\n *   - The match array, with named backreference properties.\\n *   - The zero-based match index.\\n *   - The string being traversed.\\n *   - The regex object being used to traverse the string.\\n * @example\\n *\\n * // Extracts every other digit from a string\\n * const evens = [];\\n * XRegExp.forEach('1a2345', /\\\\d/, (match, i) => {\\n *   if (i % 2) evens.push(+match[0]);\\n * });\\n * // evens -> [2, 4]\\n */\\n\\n\\nXRegExp.forEach = function (str, regex, callback) {\\n  var pos = 0;\\n  var i = -1;\\n  var match;\\n\\n  while (match = XRegExp.exec(str, regex, pos)) {\\n    // Because `regex` is provided to `callback`, the function could use the deprecated/\\n    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\\n    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\\n    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\\n    // regexes, mutating the regex will not have any effect on the iteration or matched strings,\\n    // which is a nice side effect that brings extra safety.\\n    callback(match, ++i, str, regex);\\n    pos = match.index + (match[0].length || 1);\\n  }\\n};\\n/**\\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\\n * regexes are not recompiled using XRegExp syntax.\\n *\\n * @memberOf XRegExp\\n * @param {RegExp} regex Regex to globalize.\\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\\n * @example\\n *\\n * const globalCopy = XRegExp.globalize(/regex/);\\n * globalCopy.global; // -> true\\n */\\n\\n\\nXRegExp.globalize = function (regex) {\\n  return copyRegex(regex, {\\n    addG: true\\n  });\\n};\\n/**\\n * Installs optional features according to the specified options. Can be undone using\\n * `XRegExp.uninstall`.\\n *\\n * @memberOf XRegExp\\n * @param {Object|String} options Options object or string.\\n * @example\\n *\\n * // With an options object\\n * XRegExp.install({\\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\\n *   astral: true,\\n *\\n *   // Adds named capture groups to the `groups` property of matches\\n *   namespacing: true\\n * });\\n *\\n * // With an options string\\n * XRegExp.install('astral namespacing');\\n */\\n\\n\\nXRegExp.install = function (options) {\\n  options = prepareOptions(options);\\n\\n  if (!features.astral && options.astral) {\\n    setAstral(true);\\n  }\\n\\n  if (!features.namespacing && options.namespacing) {\\n    setNamespacing(true);\\n  }\\n};\\n/**\\n * Checks whether an individual optional feature is installed.\\n *\\n * @memberOf XRegExp\\n * @param {String} feature Name of the feature to check. One of:\\n *   - `astral`\\n *   - `namespacing`\\n * @returns {boolean} Whether the feature is installed.\\n * @example\\n *\\n * XRegExp.isInstalled('astral');\\n */\\n\\n\\nXRegExp.isInstalled = function (feature) {\\n  return !!features[feature];\\n};\\n/**\\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\\n * created in another frame, when `instanceof` and `constructor` checks would fail.\\n *\\n * @memberOf XRegExp\\n * @param {*} value Object to check.\\n * @returns {boolean} Whether the object is a `RegExp` object.\\n * @example\\n *\\n * XRegExp.isRegExp('string'); // -> false\\n * XRegExp.isRegExp(/regex/i); // -> true\\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\\n */\\n\\n\\nXRegExp.isRegExp = function (value) {\\n  return toString.call(value) === '[object RegExp]';\\n}; // isType(value, 'RegExp');\\n\\n/**\\n * Returns the first matched string, or in global mode, an array containing all matched strings.\\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {RegExp} regex Regex to search with.\\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\\n *   `scope` is 'all'.\\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\\n *   mode: Array of all matched strings, or an empty array.\\n * @example\\n *\\n * // Match first\\n * XRegExp.match('abc', /\\\\w/); // -> 'a'\\n * XRegExp.match('abc', /\\\\w/g, 'one'); // -> 'a'\\n * XRegExp.match('abc', /x/g, 'one'); // -> null\\n *\\n * // Match all\\n * XRegExp.match('abc', /\\\\w/g); // -> ['a', 'b', 'c']\\n * XRegExp.match('abc', /\\\\w/, 'all'); // -> ['a', 'b', 'c']\\n * XRegExp.match('abc', /x/, 'all'); // -> []\\n */\\n\\n\\nXRegExp.match = function (str, regex, scope) {\\n  var global = regex.global && scope !== 'one' || scope === 'all';\\n  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';\\n  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`\\n\\n  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\\n    addG: !!global,\\n    removeG: scope === 'one',\\n    isInternalOnly: true\\n  }));\\n  var result = nativ.match.call(toObject(str), r2);\\n\\n  if (regex.global) {\\n    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\\n    result.index + result[0].length : 0;\\n  }\\n\\n  return global ? result || [] : result && result[0];\\n};\\n/**\\n * Retrieves the matches from searching a string using a chain of regexes that successively search\\n * within previous matches. The provided `chain` array can contain regexes and or objects with\\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\\n * backreference is passed forward to the next regex or returned.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {Array} chain Regexes that each search for matches within preceding results.\\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\\n * @example\\n *\\n * // Basic usage; matches numbers within <b> tags\\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\\n *   XRegExp('(?is)<b>.*?</b>'),\\n *   /\\\\d+/\\n * ]);\\n * // -> ['2', '4', '56']\\n *\\n * // Passing forward and returning specific backreferences\\n * html = '<a href=\\\"http://xregexp.com/api/\\\">XRegExp</a>\\\\\\n *         <a href=\\\"http://www.google.com/\\\">Google</a>';\\n * XRegExp.matchChain(html, [\\n *   {regex: /<a href=\\\"([^\\\"]+)\\\">/i, backref: 1},\\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\\n * ]);\\n * // -> ['xregexp.com', 'www.google.com']\\n */\\n\\n\\nXRegExp.matchChain = function (str, chain) {\\n  return function recurseChain(values, level) {\\n    var item = chain[level].regex ? chain[level] : {\\n      regex: chain[level]\\n    };\\n    var matches = [];\\n\\n    function addMatch(match) {\\n      if (item.backref) {\\n        var ERR_UNDEFINED_GROUP = \\\"Backreference to undefined group: \\\".concat(item.backref);\\n        var isNamedBackref = isNaN(item.backref);\\n\\n        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\\n          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\\n          if (!(item.backref in match.groups)) {\\n            throw new ReferenceError(ERR_UNDEFINED_GROUP);\\n          }\\n        } else if (!match.hasOwnProperty(item.backref)) {\\n          throw new ReferenceError(ERR_UNDEFINED_GROUP);\\n        }\\n\\n        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];\\n        matches.push(backrefValue || '');\\n      } else {\\n        matches.push(match[0]);\\n      }\\n    }\\n\\n    var _iterator3 = _createForOfIteratorHelper(values),\\n        _step3;\\n\\n    try {\\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\n        var value = _step3.value;\\n        (0, _forEach[\\\"default\\\"])(XRegExp).call(XRegExp, value, item.regex, addMatch);\\n      }\\n    } catch (err) {\\n      _iterator3.e(err);\\n    } finally {\\n      _iterator3.f();\\n    }\\n\\n    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);\\n  }([str], 0);\\n};\\n/**\\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\\n * or regex, and the replacement can be a string or a function to be called for each match. To\\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {RegExp|String} search Search pattern to be replaced.\\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\\n *   Replacement strings can include special replacement syntax:\\n *     - $$ - Inserts a literal $ character.\\n *     - $&, $0 - Inserts the matched substring.\\n *     - $` - Inserts the string that precedes the matched substring (left context).\\n *     - $' - Inserts the string that follows the matched substring (right context).\\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\\n *       backreference n/nn.\\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\\n *       group, inserts backreference n.\\n *   Replacement functions are invoked with three or more arguments:\\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\\n *       properties of this first argument.\\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\\n *     - The zero-based index of the match within the total search string.\\n *     - The total string being searched.\\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\\n * @returns {String} New string with one or all matches replaced.\\n * @example\\n *\\n * // Regex search, using named backreferences in replacement string\\n * const name = XRegExp('(?<first>\\\\\\\\w+) (?<last>\\\\\\\\w+)');\\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\\n * // -> 'Smith, John'\\n *\\n * // Regex search, using named backreferences in replacement function\\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\\n * // -> 'Smith, John'\\n *\\n * // String search, with replace-all\\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\\n * // -> 'XRegExp builds XRegExps'\\n */\\n\\n\\nXRegExp.replace = function (str, search, replacement, scope) {\\n  var isRegex = XRegExp.isRegExp(search);\\n  var global = search.global && scope !== 'one' || scope === 'all';\\n  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';\\n  var s2 = search;\\n\\n  if (isRegex) {\\n    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\\n    // `lastIndex` isn't updated *during* replacement iterations\\n\\n    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {\\n      addG: !!global,\\n      removeG: scope === 'one',\\n      isInternalOnly: true\\n    }));\\n  } else if (global) {\\n    s2 = new RegExp(XRegExp.escape(String(search)), 'g');\\n  } // Fixed `replace` required for named backreferences, etc.\\n\\n\\n  var result = fixed.replace.call(toObject(str), s2, replacement);\\n\\n  if (isRegex && search.global) {\\n    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\\n    search.lastIndex = 0;\\n  }\\n\\n  return result;\\n};\\n/**\\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\\n * array of replacement details. Later replacements operate on the output of earlier replacements.\\n * Replacement details are accepted as an array with a regex or string to search for, the\\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\\n * replacement text syntax, which supports named backreference properties via `${name}` or\\n * `$<name>`.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {Array} replacements Array of replacement detail arrays.\\n * @returns {String} New string with all replacements.\\n * @example\\n *\\n * str = XRegExp.replaceEach(str, [\\n *   [XRegExp('(?<name>a)'), 'z${name}'],\\n *   [/b/gi, 'y'],\\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\\n *   [/f/g, ($0) => $0.toUpperCase()]\\n * ]);\\n */\\n\\n\\nXRegExp.replaceEach = function (str, replacements) {\\n  var _iterator4 = _createForOfIteratorHelper(replacements),\\n      _step4;\\n\\n  try {\\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\\n      var r = _step4.value;\\n      str = XRegExp.replace(str, r[0], r[1], r[2]);\\n    }\\n  } catch (err) {\\n    _iterator4.e(err);\\n  } finally {\\n    _iterator4.f();\\n  }\\n\\n  return str;\\n};\\n/**\\n * Splits a string into an array of strings using a regex or string separator. Matches of the\\n * separator are not included in the result array. However, if `separator` is a regex that contains\\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\\n * cross-browser.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to split.\\n * @param {RegExp|String} separator Regex or string to use for separating the string.\\n * @param {Number} [limit] Maximum number of items to include in the result array.\\n * @returns {Array} Array of substrings.\\n * @example\\n *\\n * // Basic use\\n * XRegExp.split('a b c', ' ');\\n * // -> ['a', 'b', 'c']\\n *\\n * // With limit\\n * XRegExp.split('a b c', ' ', 2);\\n * // -> ['a', 'b']\\n *\\n * // Backreferences in result array\\n * XRegExp.split('..word1..', /([a-z]+)(\\\\d+)/i);\\n * // -> ['..', 'word', '1', '..']\\n */\\n\\n\\nXRegExp.split = function (str, separator, limit) {\\n  return fixed.split.call(toObject(str), separator, limit);\\n};\\n/**\\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\\n * `sticky` arguments specify the search start position, and whether the match must start at the\\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\\n * updated for compatibility. Also fixes browser bugs compared to the native\\n * `RegExp.prototype.test` and can be used reliably cross-browser.\\n *\\n * @memberOf XRegExp\\n * @param {String} str String to search.\\n * @param {RegExp} regex Regex to search with.\\n * @param {Number} [pos=0] Zero-based index at which to start the search.\\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\\n * @returns {boolean} Whether the regex matched the provided value.\\n * @example\\n *\\n * // Basic use\\n * XRegExp.test('abc', /c/); // -> true\\n *\\n * // With pos and sticky\\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\\n */\\n// Do this the easy way :-)\\n\\n\\nXRegExp.test = function (str, regex, pos, sticky) {\\n  return !!XRegExp.exec(str, regex, pos, sticky);\\n};\\n/**\\n * Uninstalls optional features according to the specified options. All optional features start out\\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\\n *\\n * @memberOf XRegExp\\n * @param {Object|String} options Options object or string.\\n * @example\\n *\\n * // With an options object\\n * XRegExp.uninstall({\\n *   // Disables support for astral code points in Unicode addons\\n *   astral: true,\\n *\\n *   // Don't add named capture groups to the `groups` property of matches\\n *   namespacing: true\\n * });\\n *\\n * // With an options string\\n * XRegExp.uninstall('astral namespacing');\\n */\\n\\n\\nXRegExp.uninstall = function (options) {\\n  options = prepareOptions(options);\\n\\n  if (features.astral && options.astral) {\\n    setAstral(false);\\n  }\\n\\n  if (features.namespacing && options.namespacing) {\\n    setNamespacing(false);\\n  }\\n};\\n/**\\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\\n * `flags` argument.\\n *\\n * @memberOf XRegExp\\n * @param {Array} patterns Regexes and strings to combine.\\n * @param {String} [flags] Any combination of XRegExp flags.\\n * @param {Object} [options] Options object with optional properties:\\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\\n * @returns {RegExp} Union of the provided regexes and strings.\\n * @example\\n *\\n * XRegExp.union(['a+b*c', /(dogs)\\\\1/, /(cats)\\\\1/], 'i');\\n * // -> /a\\\\+b\\\\*c|(dogs)\\\\1|(cats)\\\\2/i\\n *\\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\\n * // -> /manbearpig/i\\n */\\n\\n\\nXRegExp.union = function (patterns, flags, options) {\\n  options = options || {};\\n  var conjunction = options.conjunction || 'or';\\n  var numCaptures = 0;\\n  var numPriorCaptures;\\n  var captureNames;\\n\\n  function rewrite(match, paren, backref) {\\n    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group\\n\\n    if (paren) {\\n      ++numCaptures; // If the current capture has a name, preserve the name\\n\\n      if (name) {\\n        return \\\"(?<\\\".concat(name, \\\">\\\");\\n      } // Backreference\\n\\n    } else if (backref) {\\n      // Rewrite the backreference\\n      return \\\"\\\\\\\\\\\".concat(+backref + numPriorCaptures);\\n    }\\n\\n    return match;\\n  }\\n\\n  if (!(isType(patterns, 'Array') && patterns.length)) {\\n    throw new TypeError('Must provide a nonempty array of patterns to merge');\\n  }\\n\\n  var parts = /(\\\\()(?!\\\\?)|\\\\\\\\([1-9]\\\\d*)|\\\\\\\\[\\\\s\\\\S]|\\\\[(?:[^\\\\\\\\\\\\]]|\\\\\\\\[\\\\s\\\\S])*\\\\]/g;\\n  var output = [];\\n\\n  var _iterator5 = _createForOfIteratorHelper(patterns),\\n      _step5;\\n\\n  try {\\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\\n      var pattern = _step5.value;\\n\\n      if (XRegExp.isRegExp(pattern)) {\\n        numPriorCaptures = numCaptures;\\n        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\\n        // independently valid; helps keep this simple. Named captures are put back\\n\\n        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\\n      } else {\\n        output.push(XRegExp.escape(pattern));\\n      }\\n    }\\n  } catch (err) {\\n    _iterator5.e(err);\\n  } finally {\\n    _iterator5.f();\\n  }\\n\\n  var separator = conjunction === 'none' ? '' : '|';\\n  return XRegExp(output.join(separator), flags);\\n}; // ==--------------------------==\\n// Fixed/extended native methods\\n// ==--------------------------==\\n\\n/**\\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\\n *\\n * @memberOf RegExp\\n * @param {String} str String to search.\\n * @returns {Array} Match array with named backreference properties, or `null`.\\n */\\n\\n\\nfixed.exec = function (str) {\\n  var origLastIndex = this.lastIndex;\\n  var match = nativ.exec.apply(this, arguments);\\n\\n  if (match) {\\n    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\\n    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\\n    // in standards mode follows the spec.\\n    if (!correctExecNpcg && match.length > 1 && (0, _includes[\\\"default\\\"])(match).call(match, '')) {\\n      var _context3;\\n\\n      var r2 = copyRegex(this, {\\n        removeG: true,\\n        isInternalOnly: true\\n      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\\n      // matching due to characters outside the match\\n\\n      nativ.replace.call((0, _slice[\\\"default\\\"])(_context3 = String(str)).call(_context3, match.index), r2, function () {\\n        var len = arguments.length; // Skip index 0 and the last 2\\n\\n        for (var i = 1; i < len - 2; ++i) {\\n          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {\\n            match[i] = undefined;\\n          }\\n        }\\n      });\\n    } // Attach named capture properties\\n\\n\\n    var groupsObject = match;\\n\\n    if (XRegExp.isInstalled('namespacing')) {\\n      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\\n      match.groups = (0, _create[\\\"default\\\"])(null);\\n      groupsObject = match.groups;\\n    }\\n\\n    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\\n      // Skip index 0\\n      for (var i = 1; i < match.length; ++i) {\\n        var name = this[REGEX_DATA].captureNames[i - 1];\\n\\n        if (name) {\\n          groupsObject[name] = match[i];\\n        }\\n      }\\n    } // Fix browsers that increment `lastIndex` after zero-length matches\\n\\n\\n    if (this.global && !match[0].length && this.lastIndex > match.index) {\\n      this.lastIndex = match.index;\\n    }\\n  }\\n\\n  if (!this.global) {\\n    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\\n    this.lastIndex = origLastIndex;\\n  }\\n\\n  return match;\\n};\\n/**\\n * Fixes browser bugs in the native `RegExp.prototype.test`.\\n *\\n * @memberOf RegExp\\n * @param {String} str String to search.\\n * @returns {boolean} Whether the regex matched the provided value.\\n */\\n\\n\\nfixed.test = function (str) {\\n  // Do this the easy way :-)\\n  return !!fixed.exec.call(this, str);\\n};\\n/**\\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\\n * bugs in the native `String.prototype.match`.\\n *\\n * @memberOf String\\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\\n *   the result of calling `regex.exec(this)`.\\n */\\n\\n\\nfixed.match = function (regex) {\\n  if (!XRegExp.isRegExp(regex)) {\\n    // Use the native `RegExp` rather than `XRegExp`\\n    regex = new RegExp(regex);\\n  } else if (regex.global) {\\n    var result = nativ.match.apply(this, arguments); // Fixes IE bug\\n\\n    regex.lastIndex = 0;\\n    return result;\\n  }\\n\\n  return fixed.exec.call(regex, toObject(this));\\n};\\n/**\\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\\n * (`flags`) argument. Use via `XRegExp.replace`.\\n *\\n * @memberOf String\\n * @param {RegExp|String} search Search pattern to be replaced.\\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\\n * @returns {string} New string with one or all matches replaced.\\n */\\n\\n\\nfixed.replace = function (search, replacement) {\\n  var isRegex = XRegExp.isRegExp(search);\\n  var origLastIndex;\\n  var captureNames;\\n  var result;\\n\\n  if (isRegex) {\\n    if (search[REGEX_DATA]) {\\n      captureNames = search[REGEX_DATA].captureNames;\\n    } // Only needed if `search` is nonglobal\\n\\n\\n    origLastIndex = search.lastIndex;\\n  } else {\\n    search += ''; // Type-convert\\n  } // Don't use `typeof`; some older browsers return 'function' for regex objects\\n\\n\\n  if (isType(replacement, 'Function')) {\\n    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\\n    // functions isn't type-converted to a string\\n    result = nativ.replace.call(String(this), search, function () {\\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n      }\\n\\n      if (captureNames) {\\n        var groupsObject;\\n\\n        if (XRegExp.isInstalled('namespacing')) {\\n          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\\n          groupsObject = (0, _create[\\\"default\\\"])(null);\\n          args.push(groupsObject);\\n        } else {\\n          // Change the `args[0]` string primitive to a `String` object that can store\\n          // properties. This really does need to use `String` as a constructor\\n          args[0] = new String(args[0]);\\n          groupsObject = args[0];\\n        } // Store named backreferences\\n\\n\\n        for (var i = 0; i < captureNames.length; ++i) {\\n          if (captureNames[i]) {\\n            groupsObject[captureNames[i]] = args[i + 1];\\n          }\\n        }\\n      } // ES6 specs the context for replacement functions as `undefined`\\n\\n\\n      return replacement.apply(void 0, args);\\n    });\\n  } else {\\n    // Ensure that the last value of `args` will be a string when given nonstring `this`,\\n    // while still throwing on null or undefined context\\n    result = nativ.replace.call(this == null ? this : String(this), search, function () {\\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n        args[_key2] = arguments[_key2];\\n      }\\n\\n      return nativ.replace.call(String(replacement), replacementToken, replacer);\\n\\n      function replacer($0, bracketed, angled, dollarToken) {\\n        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces\\n\\n        if (bracketed) {\\n          // XRegExp behavior for `${n}` or `$<n>`:\\n          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\\n          //    entire match. Any number of leading zeros may be used.\\n          // 2. Backreference to named capture `n`, if it exists and is not an integer\\n          //    overridden by numbered capture. In practice, this does not overlap with\\n          //    numbered capture since XRegExp does not allow named capture to use a bare\\n          //    integer as the name.\\n          // 3. If the name or number does not refer to an existing capturing group, it's\\n          //    an error.\\n          var n = +bracketed; // Type-convert; drop leading zeros\\n\\n          if (n <= args.length - 3) {\\n            return args[n] || '';\\n          } // Groups with the same name is an error, else would need `lastIndexOf`\\n\\n\\n          n = captureNames ? (0, _indexOf[\\\"default\\\"])(captureNames).call(captureNames, bracketed) : -1;\\n\\n          if (n < 0) {\\n            throw new SyntaxError(\\\"Backreference to undefined group \\\".concat($0));\\n          }\\n\\n          return args[n + 1] || '';\\n        } // Else, special variable or numbered backreference without curly braces\\n\\n\\n        if (dollarToken === '$') {\\n          // $$\\n          return '$';\\n        }\\n\\n        if (dollarToken === '&' || +dollarToken === 0) {\\n          // $&, $0 (not followed by 1-9), $00\\n          return args[0];\\n        }\\n\\n        if (dollarToken === '`') {\\n          var _context4;\\n\\n          // $` (left context)\\n          return (0, _slice[\\\"default\\\"])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);\\n        }\\n\\n        if (dollarToken === \\\"'\\\") {\\n          var _context5;\\n\\n          // $' (right context)\\n          return (0, _slice[\\\"default\\\"])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);\\n        } // Else, numbered backreference without braces\\n\\n\\n        dollarToken = +dollarToken; // Type-convert; drop leading zero\\n        // XRegExp behavior for `$n` and `$nn`:\\n        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\\n        // - `$1` is an error if no capturing groups.\\n        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\\n        //   instead.\\n        // - `$01` is `$1` if at least one capturing group, else it's an error.\\n        // - `$0` (not followed by 1-9) and `$00` are the entire match.\\n        // Native behavior, for comparison:\\n        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\\n        // - `$1` is a literal `$1` if no capturing groups.\\n        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\\n        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\\n        // - `$0` is a literal `$0`.\\n\\n        if (!isNaN(dollarToken)) {\\n          if (dollarToken > args.length - 3) {\\n            throw new SyntaxError(\\\"Backreference to undefined group \\\".concat($0));\\n          }\\n\\n          return args[dollarToken] || '';\\n        } // `$` followed by an unsupported char is an error, unlike native JS\\n\\n\\n        throw new SyntaxError(\\\"Invalid token \\\".concat($0));\\n      }\\n    });\\n  }\\n\\n  if (isRegex) {\\n    if (search.global) {\\n      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\\n      search.lastIndex = 0;\\n    } else {\\n      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\\n      search.lastIndex = origLastIndex;\\n    }\\n  }\\n\\n  return result;\\n};\\n/**\\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\\n *\\n * @memberOf String\\n * @param {RegExp|String} separator Regex or string to use for separating the string.\\n * @param {Number} [limit] Maximum number of items to include in the result array.\\n * @returns {!Array} Array of substrings.\\n */\\n\\n\\nfixed.split = function (separator, limit) {\\n  if (!XRegExp.isRegExp(separator)) {\\n    // Browsers handle nonregex split correctly, so use the faster native method\\n    return nativ.split.apply(this, arguments);\\n  }\\n\\n  var str = String(this);\\n  var output = [];\\n  var origLastIndex = separator.lastIndex;\\n  var lastLastIndex = 0;\\n  var lastLength; // Values for `limit`, per the spec:\\n  // If undefined: pow(2,32) - 1\\n  // If 0, Infinity, or NaN: 0\\n  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\\n  // If negative number: pow(2,32) - floor(abs(limit))\\n  // If other: Type-convert, then use the above rules\\n  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\\n  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\\n\\n  limit = (limit === undefined ? -1 : limit) >>> 0;\\n  (0, _forEach[\\\"default\\\"])(XRegExp).call(XRegExp, str, separator, function (match) {\\n    // This condition is not the same as `if (match[0].length)`\\n    if (match.index + match[0].length > lastLastIndex) {\\n      output.push((0, _slice[\\\"default\\\"])(str).call(str, lastLastIndex, match.index));\\n\\n      if (match.length > 1 && match.index < str.length) {\\n        Array.prototype.push.apply(output, (0, _slice[\\\"default\\\"])(match).call(match, 1));\\n      }\\n\\n      lastLength = match[0].length;\\n      lastLastIndex = match.index + lastLength;\\n    }\\n  });\\n\\n  if (lastLastIndex === str.length) {\\n    if (!nativ.test.call(separator, '') || lastLength) {\\n      output.push('');\\n    }\\n  } else {\\n    output.push((0, _slice[\\\"default\\\"])(str).call(str, lastLastIndex));\\n  }\\n\\n  separator.lastIndex = origLastIndex;\\n  return output.length > limit ? (0, _slice[\\\"default\\\"])(output).call(output, 0, limit) : output;\\n}; // ==--------------------------==\\n// Built-in syntax/flag tokens\\n// ==--------------------------==\\n\\n/*\\n * Letter escapes that natively match literal characters: `\\\\a`, `\\\\A`, etc. These should be\\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\\n * consistency and to reserve their syntax, but lets them be superseded by addons.\\n */\\n\\n\\nXRegExp.addToken(/\\\\\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\\\dA-Fa-f]{4}|{[\\\\dA-Fa-f]+})|x(?![\\\\dA-Fa-f]{2}))/, function (match, scope) {\\n  // \\\\B is allowed in default scope only\\n  if (match[1] === 'B' && scope === defaultScope) {\\n    return match[0];\\n  }\\n\\n  throw new SyntaxError(\\\"Invalid escape \\\".concat(match[0]));\\n}, {\\n  scope: 'all',\\n  leadChar: '\\\\\\\\'\\n});\\n/*\\n * Unicode code point escape with curly braces: `\\\\u{N..}`. `N..` is any one or more digit\\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\\n * if you follow a `\\\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\\n * if you use the same in a character class.\\n */\\n\\nXRegExp.addToken(/\\\\\\\\u{([\\\\dA-Fa-f]+)}/, function (match, scope, flags) {\\n  var code = dec(match[1]);\\n\\n  if (code > 0x10FFFF) {\\n    throw new SyntaxError(\\\"Invalid Unicode code point \\\".concat(match[0]));\\n  }\\n\\n  if (code <= 0xFFFF) {\\n    // Converting to \\\\uNNNN avoids needing to escape the literal character and keep it\\n    // separate from preceding tokens\\n    return \\\"\\\\\\\\u\\\".concat(pad4(hex(code)));\\n  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\\n\\n\\n  if (hasNativeU && (0, _includes[\\\"default\\\"])(flags).call(flags, 'u')) {\\n    return match[0];\\n  }\\n\\n  throw new SyntaxError('Cannot use Unicode code point above \\\\\\\\u{FFFF} without flag u');\\n}, {\\n  scope: 'all',\\n  leadChar: '\\\\\\\\'\\n});\\n/*\\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\\n * character class endings can't be determined.\\n */\\n\\nXRegExp.addToken(/\\\\[(\\\\^?)\\\\]/, // For cross-browser compatibility with ES3, convert [] to \\\\b\\\\B and [^] to [\\\\s\\\\S].\\n// (?!) should work like \\\\b\\\\B, but is unreliable in some versions of Firefox\\n\\n/* eslint-disable no-confusing-arrow */\\nfunction (match) {\\n  return match[1] ? '[\\\\\\\\s\\\\\\\\S]' : '\\\\\\\\b\\\\\\\\B';\\n},\\n/* eslint-enable no-confusing-arrow */\\n{\\n  leadChar: '['\\n});\\n/*\\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\\n * free-spacing mode (flag x).\\n */\\n\\nXRegExp.addToken(/\\\\(\\\\?#[^)]*\\\\)/, getContextualTokenSeparator, {\\n  leadChar: '('\\n});\\n/*\\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\\n */\\n\\nXRegExp.addToken(/\\\\s+|#[^\\\\n]*\\\\n?/, getContextualTokenSeparator, {\\n  flag: 'x'\\n});\\n/*\\n * Dot, in dotall mode (aka singleline mode, flag s) only.\\n */\\n\\nXRegExp.addToken(/\\\\./, function () {\\n  return '[\\\\\\\\s\\\\\\\\S]';\\n}, {\\n  flag: 's',\\n  leadChar: '.'\\n});\\n/*\\n * Named backreference: `\\\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\\n * and $ only. Also allows numbered backreferences as `\\\\k<n>`.\\n */\\n\\nXRegExp.addToken(/\\\\\\\\k<([\\\\w$]+)>/, function (match) {\\n  var _context6, _context7;\\n\\n  // Groups with the same name is an error, else would need `lastIndexOf`\\n  var index = isNaN(match[1]) ? (0, _indexOf[\\\"default\\\"])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];\\n  var endIndex = match.index + match[0].length;\\n\\n  if (!index || index > this.captureNames.length) {\\n    throw new SyntaxError(\\\"Backreference to undefined group \\\".concat(match[0]));\\n  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\\n  // inadvertedly changing `(?<n>)\\\\k<n>1` to `()\\\\11`.\\n\\n\\n  return (0, _concat[\\\"default\\\"])(_context7 = \\\"\\\\\\\\\\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');\\n}, {\\n  leadChar: '\\\\\\\\'\\n});\\n/*\\n * Numbered backreference or octal, plus any following digits: `\\\\0`, `\\\\11`, etc. Octals except `\\\\0`\\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\\\99` in regex syntax.\\n */\\n\\nXRegExp.addToken(/\\\\\\\\(\\\\d+)/, function (match, scope) {\\n  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {\\n    throw new SyntaxError(\\\"Cannot use octal escape or backreference to undefined group \\\".concat(match[0]));\\n  }\\n\\n  return match[0];\\n}, {\\n  scope: 'all',\\n  leadChar: '\\\\\\\\'\\n});\\n/*\\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\\n * Python-style named capture as octals.\\n */\\n\\nXRegExp.addToken(/\\\\(\\\\?P?<([\\\\w$]+)>/, function (match) {\\n  var _context8;\\n\\n  // Disallow bare integers as names because named backreferences are added to match arrays\\n  // and therefore numeric properties may lead to incorrect lookups\\n  if (!isNaN(match[1])) {\\n    throw new SyntaxError(\\\"Cannot use integer as capture name \\\".concat(match[0]));\\n  }\\n\\n  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\\n    throw new SyntaxError(\\\"Cannot use reserved word as capture name \\\".concat(match[0]));\\n  }\\n\\n  if ((0, _includes[\\\"default\\\"])(_context8 = this.captureNames).call(_context8, match[1])) {\\n    throw new SyntaxError(\\\"Cannot use same name for multiple groups \\\".concat(match[0]));\\n  }\\n\\n  this.captureNames.push(match[1]);\\n  this.hasNamedCapture = true;\\n  return '(';\\n}, {\\n  leadChar: '('\\n});\\n/*\\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\\n * groups. Also adds explicit capture mode (flag n).\\n */\\n\\nXRegExp.addToken(/\\\\((?!\\\\?)/, function (match, scope, flags) {\\n  if ((0, _includes[\\\"default\\\"])(flags).call(flags, 'n')) {\\n    return '(?:';\\n  }\\n\\n  this.captureNames.push(null);\\n  return '(';\\n}, {\\n  optionalFlags: 'n',\\n  leadChar: '('\\n});\\nvar _default = XRegExp;\\nexports[\\\"default\\\"] = _default;\\nmodule.exports = exports.default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_createForOfIteratorHelper\",\"o\",\"allowArrayLike\",\"it\",\"_symbol\",\"_getIteratorMethod2\",\"_isArray\",\"_unsupportedIterableToArray\",\"length\",\"i\",\"F\",\"s\",\"n\",\"done\",\"value\",\"e\",\"_e\",\"f\",\"TypeError\",\"normalCompletion\",\"didErr\",\"err\",\"_getIterator2\",\"step\",\"next\",\"_e2\",\"minLen\",\"_context9\",\"_arrayLikeToArray\",\"_slice\",\"Object\",\"prototype\",\"toString\",\"call\",\"constructor\",\"name\",\"_from\",\"test\",\"arr\",\"len\",\"arr2\",\"Array\",\"hasNativeFlag\",\"flag\",\"isSupported\",\"RegExp\",\"replace\",\"exception\",\"augment\",\"regex\",\"captureNames\",\"xSource\",\"xFlags\",\"isInternalOnly\",\"_context\",\"__proto__\",\"XRegExp\",\"p\",\"source\",\"flags\",\"_sort\",\"split\",\"join\",\"clipDuplicates\",\"str\",\"nativ\",\"copyRegex\",\"options\",\"_context2\",\"isRegExp\",\"xData\",\"hasFlagsProp\",\"_flags\",\"exec\",\"flagsToAdd\",\"flagsToRemove\",\"xregexpSource\",\"xregexpFlags\",\"removeG\",\"removeY\",\"concat\",\"addG\",\"addY\",\"undefined\",\"dec\",\"hex\",\"_parseInt2\",\"getContextualTokenSeparator\",\"match\",\"scope\",\"_includes\",\"pattern\",\"pos\",\"isType\",\"type\",\"pad4\",\"prepareFlags\",\"SyntaxError\",\"$0\",\"$1\",\"_iterator\",\"_step\",\"registeredFlags\",\"prepareOptions\",\"_forEach\",\"registerFlag\",\"Error\",\"toObject\",\"String\",\"isInstalled\",\"patternCache\",\"context\",\"hasNamedCapture\",\"defaultScope\",\"output\",\"applied\",\"appliedPattern\",\"appliedFlags\",\"tokens\",\"leadChar\",\"result\",\"t\",\"matchLength\",\"handler\",\"reparse\",\"_XRegExp$exec\",\"nativeTokens\",\"token\",\"_XRegExp$exec2\",\"_slicedToArray2\",\"classScope\",\"captures\",\"generated\",\"_interopRequireDefault\",\"_Object$defineProperty\",\"_concat\",\"_indexOf\",\"_create\",\"features\",\"astral\",\"namespacing\",\"fixed\",\"regexCache\",\"replacementToken\",\"correctExecNpcg\",\"_ref\",\"hasNativeU\",\"hasNativeY\",\"g\",\"m\",\"u\",\"y\",\"version\",\"_clipDuplicates\",\"_hasNativeFlag\",\"_dec\",\"_hex\",\"_pad4\",\"addToken\",\"XRegExp.addToken\",\"optionalFlags\",\"_iterator2\",\"_step2\",\"push\",\"cache\",\"flush\",\"XRegExp.cache\",\"XRegExp.cache.flush\",\"cacheName\",\"escape\",\"XRegExp.escape\",\"XRegExp.exec\",\"sticky\",\"cacheKey\",\"fakeY\",\"r2\",\"lastIndex\",\"pop\",\"forEach\",\"XRegExp.forEach\",\"callback\",\"index\",\"globalize\",\"XRegExp.globalize\",\"install\",\"XRegExp.install\",\"on\",\"XRegExp.isInstalled\",\"feature\",\"XRegExp.isRegExp\",\"XRegExp.match\",\"matchChain\",\"XRegExp.matchChain\",\"chain\",\"recurseChain\",\"values\",\"level\",\"addMatch\",\"item\",\"backref\",\"ERR_UNDEFINED_GROUP\",\"isNamedBackref\",\"isNaN\",\"groups\",\"ReferenceError\",\"hasOwnProperty\",\"backrefValue\",\"matches\",\"_iterator3\",\"_step3\",\"XRegExp.replace\",\"search\",\"replacement\",\"isRegex\",\"s2\",\"replaceEach\",\"XRegExp.replaceEach\",\"replacements\",\"_iterator4\",\"_step4\",\"r\",\"XRegExp.split\",\"separator\",\"limit\",\"XRegExp.test\",\"uninstall\",\"XRegExp.uninstall\",\"union\",\"XRegExp.union\",\"patterns\",\"rewrite\",\"paren\",\"numCaptures\",\"numPriorCaptures\",\"conjunction\",\"parts\",\"_iterator5\",\"_step5\",\"fixed.exec\",\"origLastIndex\",\"apply\",\"arguments\",\"_context3\",\"groupsObject\",\"fixed.test\",\"fixed.match\",\"fixed.replace\",\"_len\",\"args\",\"_key\",\"_len2\",\"_key2\",\"replacer\",\"bracketed\",\"angled\",\"dollarToken\",\"_context4\",\"_context5\",\"fixed.split\",\"lastLastIndex\",\"lastLength\",\"code\",\"_context6\",\"_context7\",\"endIndex\",\"input\",\"_context8\",\"default\"]\n}\n"]