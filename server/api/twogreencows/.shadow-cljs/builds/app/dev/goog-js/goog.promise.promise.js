["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/promise/promise.js"],"~:js","goog.provide(\"goog.Promise\");\ngoog.require(\"goog.Thenable\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.async.FreeList\");\ngoog.require(\"goog.async.run\");\ngoog.require(\"goog.async.throwException\");\ngoog.require(\"goog.debug.Error\");\ngoog.require(\"goog.promise.Resolver\");\ngoog.Promise = function(resolver, opt_context) {\n  this.state_ = goog.Promise.State_.PENDING;\n  this.result_ = undefined;\n  this.parent_ = null;\n  this.callbackEntries_ = null;\n  this.callbackEntriesTail_ = null;\n  this.executing_ = false;\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    this.unhandledRejectionId_ = 0;\n  } else {\n    if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n      this.hadUnhandledRejection_ = false;\n    }\n  }\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.stack_ = [];\n    this.addStackTrace_(new Error(\"created\"));\n    this.currentStep_ = 0;\n  }\n  if (resolver != goog.nullFunction) {\n    try {\n      var self = this;\n      resolver.call(opt_context, function(value) {\n        self.resolve_(goog.Promise.State_.FULFILLED, value);\n      }, function(reason) {\n        if (goog.DEBUG && !(reason instanceof goog.Promise.CancellationError)) {\n          try {\n            if (reason instanceof Error) {\n              throw reason;\n            } else {\n              throw new Error(\"Promise rejected.\");\n            }\n          } catch (e) {\n          }\n        }\n        self.resolve_(goog.Promise.State_.REJECTED, reason);\n      });\n    } catch (e) {\n      this.resolve_(goog.Promise.State_.REJECTED, e);\n    }\n  }\n};\ngoog.Promise.LONG_STACK_TRACES = goog.define(\"goog.Promise.LONG_STACK_TRACES\", false);\ngoog.Promise.UNHANDLED_REJECTION_DELAY = goog.define(\"goog.Promise.UNHANDLED_REJECTION_DELAY\", 0);\ngoog.Promise.State_ = {PENDING:0, BLOCKED:1, FULFILLED:2, REJECTED:3};\ngoog.Promise.CallbackEntry_ = function() {\n  this.child = null;\n  this.onFulfilled = null;\n  this.onRejected = null;\n  this.context = null;\n  this.next = null;\n  this.always = false;\n};\ngoog.Promise.CallbackEntry_.prototype.reset = function() {\n  this.child = null;\n  this.onFulfilled = null;\n  this.onRejected = null;\n  this.context = null;\n  this.always = false;\n};\ngoog.Promise.DEFAULT_MAX_UNUSED = goog.define(\"goog.Promise.DEFAULT_MAX_UNUSED\", 100);\ngoog.Promise.freelist_ = new goog.async.FreeList(function() {\n  return new goog.Promise.CallbackEntry_;\n}, function(item) {\n  item.reset();\n}, goog.Promise.DEFAULT_MAX_UNUSED);\ngoog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {\n  var entry = goog.Promise.freelist_.get();\n  entry.onFulfilled = onFulfilled;\n  entry.onRejected = onRejected;\n  entry.context = context;\n  return entry;\n};\ngoog.Promise.returnEntry_ = function(entry) {\n  goog.Promise.freelist_.put(entry);\n};\ngoog.Promise.resolve = function(opt_value) {\n  if (opt_value instanceof goog.Promise) {\n    return opt_value;\n  }\n  var promise = new goog.Promise(goog.nullFunction);\n  promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);\n  return promise;\n};\ngoog.Promise.reject = function(opt_reason) {\n  return new goog.Promise(function(resolve, reject) {\n    reject(opt_reason);\n  });\n};\ngoog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {\n  var isThenable = goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);\n  if (!isThenable) {\n    goog.async.run(goog.partial(onFulfilled, value));\n  }\n};\ngoog.Promise.race = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    if (!promises.length) {\n      resolve(undefined);\n    }\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, resolve, reject);\n    }\n  });\n};\ngoog.Promise.all = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toFulfill = promises.length;\n    var values = [];\n    if (!toFulfill) {\n      resolve(values);\n      return;\n    }\n    var onFulfill = function(index, value) {\n      toFulfill--;\n      values[index] = value;\n      if (toFulfill == 0) {\n        resolve(values);\n      }\n    };\n    var onReject = function(reason) {\n      reject(reason);\n    };\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject);\n    }\n  });\n};\ngoog.Promise.allSettled = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toSettle = promises.length;\n    var results = [];\n    if (!toSettle) {\n      resolve(results);\n      return;\n    }\n    var onSettled = function(index, fulfilled, result) {\n      toSettle--;\n      results[index] = fulfilled ? {fulfilled:true, value:result} : {fulfilled:false, reason:result};\n      if (toSettle == 0) {\n        resolve(results);\n      }\n    };\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, goog.partial(onSettled, i, true), goog.partial(onSettled, i, false));\n    }\n  });\n};\ngoog.Promise.firstFulfilled = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toReject = promises.length;\n    var reasons = [];\n    if (!toReject) {\n      resolve(undefined);\n      return;\n    }\n    var onFulfill = function(value) {\n      resolve(value);\n    };\n    var onReject = function(index, reason) {\n      toReject--;\n      reasons[index] = reason;\n      if (toReject == 0) {\n        reject(reasons);\n      }\n    };\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i));\n    }\n  });\n};\ngoog.Promise.withResolver = function() {\n  var resolve, reject;\n  var promise = new goog.Promise(function(rs, rj) {\n    resolve = rs;\n    reject = rj;\n  });\n  return new goog.Promise.Resolver_(promise, resolve, reject);\n};\ngoog.Promise.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {\n  if (opt_onFulfilled != null) {\n    goog.asserts.assertFunction(opt_onFulfilled, \"opt_onFulfilled should be a function.\");\n  }\n  if (opt_onRejected != null) {\n    goog.asserts.assertFunction(opt_onRejected, \"opt_onRejected should be a function. Did you pass opt_context \" + \"as the second argument instead of the third?\");\n  }\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error(\"then\"));\n  }\n  return this.addChildPromise_(goog.isFunction(opt_onFulfilled) ? opt_onFulfilled : null, goog.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);\n};\ngoog.Thenable.addImplementation(goog.Promise);\ngoog.Promise.prototype.thenVoid = function(opt_onFulfilled, opt_onRejected, opt_context) {\n  if (opt_onFulfilled != null) {\n    goog.asserts.assertFunction(opt_onFulfilled, \"opt_onFulfilled should be a function.\");\n  }\n  if (opt_onRejected != null) {\n    goog.asserts.assertFunction(opt_onRejected, \"opt_onRejected should be a function. Did you pass opt_context \" + \"as the second argument instead of the third?\");\n  }\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error(\"then\"));\n  }\n  this.addCallbackEntry_(goog.Promise.getCallbackEntry_(opt_onFulfilled || goog.nullFunction, opt_onRejected || null, opt_context));\n};\ngoog.Promise.prototype.thenAlways = function(onSettled, opt_context) {\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error(\"thenAlways\"));\n  }\n  var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);\n  entry.always = true;\n  this.addCallbackEntry_(entry);\n  return this;\n};\ngoog.Promise.prototype.thenCatch = function(onRejected, opt_context) {\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error(\"thenCatch\"));\n  }\n  return this.addChildPromise_(null, onRejected, opt_context);\n};\ngoog.Promise.prototype.cancel = function(opt_message) {\n  if (this.state_ == goog.Promise.State_.PENDING) {\n    var err = new goog.Promise.CancellationError(opt_message);\n    goog.async.run(function() {\n      this.cancelInternal_(err);\n    }, this);\n  }\n};\ngoog.Promise.prototype.cancelInternal_ = function(err) {\n  if (this.state_ == goog.Promise.State_.PENDING) {\n    if (this.parent_) {\n      this.parent_.cancelChild_(this, err);\n      this.parent_ = null;\n    } else {\n      this.resolve_(goog.Promise.State_.REJECTED, err);\n    }\n  }\n};\ngoog.Promise.prototype.cancelChild_ = function(childPromise, err) {\n  if (!this.callbackEntries_) {\n    return;\n  }\n  var childCount = 0;\n  var childEntry = null;\n  var beforeChildEntry = null;\n  for (var entry = this.callbackEntries_; entry; entry = entry.next) {\n    if (!entry.always) {\n      childCount++;\n      if (entry.child == childPromise) {\n        childEntry = entry;\n      }\n      if (childEntry && childCount > 1) {\n        break;\n      }\n    }\n    if (!childEntry) {\n      beforeChildEntry = entry;\n    }\n  }\n  if (childEntry) {\n    if (this.state_ == goog.Promise.State_.PENDING && childCount == 1) {\n      this.cancelInternal_(err);\n    } else {\n      if (beforeChildEntry) {\n        this.removeEntryAfter_(beforeChildEntry);\n      } else {\n        this.popEntry_();\n      }\n      this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err);\n    }\n  }\n};\ngoog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {\n  if (!this.hasEntry_() && (this.state_ == goog.Promise.State_.FULFILLED || this.state_ == goog.Promise.State_.REJECTED)) {\n    this.scheduleCallbacks_();\n  }\n  this.queueEntry_(callbackEntry);\n};\ngoog.Promise.prototype.addChildPromise_ = function(onFulfilled, onRejected, opt_context) {\n  var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);\n  callbackEntry.child = new goog.Promise(function(resolve, reject) {\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\n      try {\n        var result = onFulfilled.call(opt_context, value);\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    } : resolve;\n    callbackEntry.onRejected = onRejected ? function(reason) {\n      try {\n        var result = onRejected.call(opt_context, reason);\n        if (result === undefined && reason instanceof goog.Promise.CancellationError) {\n          reject(reason);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    } : reject;\n  });\n  callbackEntry.child.parent_ = this;\n  this.addCallbackEntry_(callbackEntry);\n  return callbackEntry.child;\n};\ngoog.Promise.prototype.unblockAndFulfill_ = function(value) {\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\n  this.state_ = goog.Promise.State_.PENDING;\n  this.resolve_(goog.Promise.State_.FULFILLED, value);\n};\ngoog.Promise.prototype.unblockAndReject_ = function(reason) {\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\n  this.state_ = goog.Promise.State_.PENDING;\n  this.resolve_(goog.Promise.State_.REJECTED, reason);\n};\ngoog.Promise.prototype.resolve_ = function(state, x) {\n  if (this.state_ != goog.Promise.State_.PENDING) {\n    return;\n  }\n  if (this === x) {\n    state = goog.Promise.State_.REJECTED;\n    x = new TypeError(\"Promise cannot resolve to itself\");\n  }\n  this.state_ = goog.Promise.State_.BLOCKED;\n  var isThenable = goog.Promise.maybeThen_(x, this.unblockAndFulfill_, this.unblockAndReject_, this);\n  if (isThenable) {\n    return;\n  }\n  this.result_ = x;\n  this.state_ = state;\n  this.parent_ = null;\n  this.scheduleCallbacks_();\n  if (state == goog.Promise.State_.REJECTED && !(x instanceof goog.Promise.CancellationError)) {\n    goog.Promise.addUnhandledRejection_(this, x);\n  }\n};\ngoog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {\n  if (value instanceof goog.Promise) {\n    value.thenVoid(onFulfilled, onRejected, context);\n    return true;\n  } else {\n    if (goog.Thenable.isImplementedBy(value)) {\n      value = value;\n      value.then(onFulfilled, onRejected, context);\n      return true;\n    } else {\n      if (goog.isObject(value)) {\n        try {\n          var then = value[\"then\"];\n          if (goog.isFunction(then)) {\n            goog.Promise.tryThen_(value, then, onFulfilled, onRejected, context);\n            return true;\n          }\n        } catch (e) {\n          onRejected.call(context, e);\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\ngoog.Promise.tryThen_ = function(thenable, then, onFulfilled, onRejected, context) {\n  var called = false;\n  var resolve = function(value) {\n    if (!called) {\n      called = true;\n      onFulfilled.call(context, value);\n    }\n  };\n  var reject = function(reason) {\n    if (!called) {\n      called = true;\n      onRejected.call(context, reason);\n    }\n  };\n  try {\n    then.call(thenable, resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n};\ngoog.Promise.prototype.scheduleCallbacks_ = function() {\n  if (!this.executing_) {\n    this.executing_ = true;\n    goog.async.run(this.executeCallbacks_, this);\n  }\n};\ngoog.Promise.prototype.hasEntry_ = function() {\n  return !!this.callbackEntries_;\n};\ngoog.Promise.prototype.queueEntry_ = function(entry) {\n  goog.asserts.assert(entry.onFulfilled != null);\n  if (this.callbackEntriesTail_) {\n    this.callbackEntriesTail_.next = entry;\n    this.callbackEntriesTail_ = entry;\n  } else {\n    this.callbackEntries_ = entry;\n    this.callbackEntriesTail_ = entry;\n  }\n};\ngoog.Promise.prototype.popEntry_ = function() {\n  var entry = null;\n  if (this.callbackEntries_) {\n    entry = this.callbackEntries_;\n    this.callbackEntries_ = entry.next;\n    entry.next = null;\n  }\n  if (!this.callbackEntries_) {\n    this.callbackEntriesTail_ = null;\n  }\n  if (entry != null) {\n    goog.asserts.assert(entry.onFulfilled != null);\n  }\n  return entry;\n};\ngoog.Promise.prototype.removeEntryAfter_ = function(previous) {\n  goog.asserts.assert(this.callbackEntries_);\n  goog.asserts.assert(previous != null);\n  if (previous.next == this.callbackEntriesTail_) {\n    this.callbackEntriesTail_ = previous;\n  }\n  previous.next = previous.next.next;\n};\ngoog.Promise.prototype.executeCallbacks_ = function() {\n  var entry = null;\n  while (entry = this.popEntry_()) {\n    if (goog.Promise.LONG_STACK_TRACES) {\n      this.currentStep_++;\n    }\n    this.executeCallback_(entry, this.state_, this.result_);\n  }\n  this.executing_ = false;\n};\ngoog.Promise.prototype.executeCallback_ = function(callbackEntry, state, result) {\n  if (state == goog.Promise.State_.REJECTED && callbackEntry.onRejected && !callbackEntry.always) {\n    this.removeUnhandledRejection_();\n  }\n  if (callbackEntry.child) {\n    callbackEntry.child.parent_ = null;\n    goog.Promise.invokeCallback_(callbackEntry, state, result);\n  } else {\n    try {\n      callbackEntry.always ? callbackEntry.onFulfilled.call(callbackEntry.context) : goog.Promise.invokeCallback_(callbackEntry, state, result);\n    } catch (err) {\n      goog.Promise.handleRejection_.call(null, err);\n    }\n  }\n  goog.Promise.returnEntry_(callbackEntry);\n};\ngoog.Promise.invokeCallback_ = function(callbackEntry, state, result) {\n  if (state == goog.Promise.State_.FULFILLED) {\n    callbackEntry.onFulfilled.call(callbackEntry.context, result);\n  } else {\n    if (callbackEntry.onRejected) {\n      callbackEntry.onRejected.call(callbackEntry.context, result);\n    }\n  }\n};\ngoog.Promise.prototype.addStackTrace_ = function(err) {\n  if (goog.Promise.LONG_STACK_TRACES && typeof err.stack === \"string\") {\n    var trace = err.stack.split(\"\\n\", 4)[3];\n    var message = err.message;\n    message += Array(11 - message.length).join(\" \");\n    this.stack_.push(message + trace);\n  }\n};\ngoog.Promise.prototype.appendLongStack_ = function(err) {\n  if (goog.Promise.LONG_STACK_TRACES && err && typeof err.stack === \"string\" && this.stack_.length) {\n    var longTrace = [\"Promise trace:\"];\n    for (var promise = this; promise; promise = promise.parent_) {\n      for (var i = this.currentStep_; i >= 0; i--) {\n        longTrace.push(promise.stack_[i]);\n      }\n      longTrace.push(\"Value: \" + \"[\" + (promise.state_ == goog.Promise.State_.REJECTED ? \"REJECTED\" : \"FULFILLED\") + \"] \" + \"\\x3c\" + String(promise.result_) + \"\\x3e\");\n    }\n    err.stack += \"\\n\\n\" + longTrace.join(\"\\n\");\n  }\n};\ngoog.Promise.prototype.removeUnhandledRejection_ = function() {\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {\n      goog.global.clearTimeout(p.unhandledRejectionId_);\n      p.unhandledRejectionId_ = 0;\n    }\n  } else {\n    if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n      for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\n        p.hadUnhandledRejection_ = false;\n      }\n    }\n  }\n};\ngoog.Promise.addUnhandledRejection_ = function(promise, reason) {\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {\n      promise.appendLongStack_(reason);\n      goog.Promise.handleRejection_.call(null, reason);\n    }, goog.Promise.UNHANDLED_REJECTION_DELAY);\n  } else {\n    if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n      promise.hadUnhandledRejection_ = true;\n      goog.async.run(function() {\n        if (promise.hadUnhandledRejection_) {\n          promise.appendLongStack_(reason);\n          goog.Promise.handleRejection_.call(null, reason);\n        }\n      });\n    }\n  }\n};\ngoog.Promise.handleRejection_ = goog.async.throwException;\ngoog.Promise.setUnhandledRejectionHandler = function(handler) {\n  goog.Promise.handleRejection_ = handler;\n};\ngoog.Promise.CancellationError = function(opt_message) {\n  goog.Promise.CancellationError.base(this, \"constructor\", opt_message);\n};\ngoog.inherits(goog.Promise.CancellationError, goog.debug.Error);\ngoog.Promise.CancellationError.prototype.name = \"cancel\";\ngoog.Promise.Resolver_ = function(promise, resolve, reject) {\n  this.promise = promise;\n  this.resolve = resolve;\n  this.reject = reject;\n};\n","~:source","// Copyright 2013 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog.provide('goog.Promise');\n\ngoog.require('goog.Thenable');\ngoog.require('goog.asserts');\ngoog.require('goog.async.FreeList');\ngoog.require('goog.async.run');\ngoog.require('goog.async.throwException');\ngoog.require('goog.debug.Error');\ngoog.require('goog.promise.Resolver');\n\n\n\n/**\n * NOTE: This class was created in anticipation of the built-in Promise type\n * being standardized and implemented across browsers. Now that Promise is\n * available in modern browsers, and is automatically polyfilled by the Closure\n * Compiler, by default, most new code should use native `Promise`\n * instead of `goog.Promise`. However, `goog.Promise` has the\n * concept of cancellation which native Promises do not yet have. So code\n * needing cancellation may still want to use `goog.Promise`.\n *\n * Promises provide a result that may be resolved asynchronously. A Promise may\n * be resolved by being fulfilled with a fulfillment value, rejected with a\n * rejection reason, or blocked by another Promise. A Promise is said to be\n * settled if it is either fulfilled or rejected. Once settled, the Promise\n * result is immutable.\n *\n * Promises may represent results of any type, including undefined. Rejection\n * reasons are typically Errors, but may also be of any type. Closure Promises\n * allow for optional type annotations that enforce that fulfillment values are\n * of the appropriate types at compile time.\n *\n * The result of a Promise is accessible by calling `then` and registering\n * `onFulfilled` and `onRejected` callbacks. Once the Promise\n * is settled, the relevant callbacks are invoked with the fulfillment value or\n * rejection reason as argument. Callbacks are always invoked in the order they\n * were registered, even when additional `then` calls are made from inside\n * another callback. A callback is always run asynchronously sometime after the\n * scope containing the registering `then` invocation has returned.\n *\n * If a Promise is resolved with another Promise, the first Promise will block\n * until the second is settled, and then assumes the same result as the second\n * Promise. This allows Promises to depend on the results of other Promises,\n * linking together multiple asynchronous operations.\n *\n * This implementation is compatible with the Promises/A+ specification and\n * passes that specification's conformance test suite. A Closure Promise may be\n * resolved with a Promise instance (or sufficiently compatible Promise-like\n * object) created by other Promise implementations. From the specification,\n * Promise-like objects are known as \"Thenables\".\n *\n * @see http://promisesaplus.com/\n *\n * @param {function(\n *             this:RESOLVER_CONTEXT,\n *             function((TYPE|IThenable<TYPE>|Thenable)=),\n *             function(*=)): void} resolver\n *     Initialization function that is invoked immediately with `resolve`\n *     and `reject` functions as arguments. The Promise is resolved or\n *     rejected with the first argument passed to either function.\n * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the\n *     resolver function. If unspecified, the resolver function will be executed\n *     in the default scope.\n * @constructor\n * @struct\n * @final\n * @implements {goog.Thenable<TYPE>}\n * @template TYPE,RESOLVER_CONTEXT\n */\ngoog.Promise = function(resolver, opt_context) {\n  /**\n   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or\n   * BLOCKED.\n   * @private {goog.Promise.State_}\n   */\n  this.state_ = goog.Promise.State_.PENDING;\n\n  /**\n   * The settled result of the Promise. Immutable once set with either a\n   * fulfillment value or rejection reason.\n   * @private {*}\n   */\n  this.result_ = undefined;\n\n  /**\n   * For Promises created by calling `then()`, the originating parent.\n   * @private {?goog.Promise}\n   */\n  this.parent_ = null;\n\n  /**\n   * The linked list of `onFulfilled` and `onRejected` callbacks\n   * added to this Promise by calls to `then()`.\n   * @private {?goog.Promise.CallbackEntry_}\n   */\n  this.callbackEntries_ = null;\n\n  /**\n   * The tail of the linked list of `onFulfilled` and `onRejected`\n   * callbacks added to this Promise by calls to `then()`.\n   * @private {?goog.Promise.CallbackEntry_}\n   */\n  this.callbackEntriesTail_ = null;\n\n  /**\n   * Whether the Promise is in the queue of Promises to execute.\n   * @private {boolean}\n   */\n  this.executing_ = false;\n\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    /**\n     * A timeout ID used when the `UNHANDLED_REJECTION_DELAY` is greater\n     * than 0 milliseconds. The ID is set when the Promise is rejected, and\n     * cleared only if an `onRejected` callback is invoked for the\n     * Promise (or one of its descendants) before the delay is exceeded.\n     *\n     * If the rejection is not handled before the timeout completes, the\n     * rejection reason is passed to the unhandled rejection handler.\n     * @private {number}\n     */\n    this.unhandledRejectionId_ = 0;\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n    /**\n     * When the `UNHANDLED_REJECTION_DELAY` is set to 0 milliseconds, a\n     * boolean that is set if the Promise is rejected, and reset to false if an\n     * `onRejected` callback is invoked for the Promise (or one of its\n     * descendants). If the rejection is not handled before the next timestep,\n     * the rejection reason is passed to the unhandled rejection handler.\n     * @private {boolean}\n     */\n    this.hadUnhandledRejection_ = false;\n  }\n\n  if (goog.Promise.LONG_STACK_TRACES) {\n    /**\n     * A list of stack trace frames pointing to the locations where this Promise\n     * was created or had callbacks added to it. Saved to add additional context\n     * to stack traces when an exception is thrown.\n     * @private {!Array<string>}\n     */\n    this.stack_ = [];\n    this.addStackTrace_(new Error('created'));\n\n    /**\n     * Index of the most recently executed stack frame entry.\n     * @private {number}\n     */\n    this.currentStep_ = 0;\n  }\n\n  // As an optimization, we can skip this if resolver is goog.nullFunction.\n  // This value is passed internally when creating a promise which will be\n  // resolved through a more optimized path.\n  if (resolver != goog.nullFunction) {\n    try {\n      var self = this;\n      resolver.call(\n          opt_context,\n          function(value) {\n            self.resolve_(goog.Promise.State_.FULFILLED, value);\n          },\n          function(reason) {\n            if (goog.DEBUG &&\n                !(reason instanceof goog.Promise.CancellationError)) {\n              try {\n                // Promise was rejected. Step up one call frame to see why.\n                if (reason instanceof Error) {\n                  throw reason;\n                } else {\n                  throw new Error('Promise rejected.');\n                }\n              } catch (e) {\n                // Only thrown so browser dev tools can catch rejections of\n                // promises when the option to break on caught exceptions is\n                // activated.\n              }\n            }\n            self.resolve_(goog.Promise.State_.REJECTED, reason);\n          });\n    } catch (e) {\n      this.resolve_(goog.Promise.State_.REJECTED, e);\n    }\n  }\n};\n\n\n/**\n * @define {boolean} Whether traces of `then` calls should be included in\n * exceptions thrown\n */\ngoog.Promise.LONG_STACK_TRACES =\n    goog.define('goog.Promise.LONG_STACK_TRACES', false);\n\n\n/**\n * @define {number} The delay in milliseconds before a rejected Promise's reason\n * is passed to the rejection handler. By default, the rejection handler\n * rethrows the rejection reason so that it appears in the developer console or\n * `window.onerror` handler.\n *\n * Rejections are rethrown as quickly as possible by default. A negative value\n * disables rejection handling entirely.\n */\ngoog.Promise.UNHANDLED_REJECTION_DELAY =\n    goog.define('goog.Promise.UNHANDLED_REJECTION_DELAY', 0);\n\n\n/**\n * The possible internal states for a Promise. These states are not directly\n * observable to external callers.\n * @enum {number}\n * @private\n */\ngoog.Promise.State_ = {\n  /** The Promise is waiting for resolution. */\n  PENDING: 0,\n\n  /** The Promise is blocked waiting for the result of another Thenable. */\n  BLOCKED: 1,\n\n  /** The Promise has been resolved with a fulfillment value. */\n  FULFILLED: 2,\n\n  /** The Promise has been resolved with a rejection reason. */\n  REJECTED: 3\n};\n\n\n\n/**\n * Entries in the callback chain. Each call to `then`,\n * `thenCatch`, or `thenAlways` creates an entry containing the\n * functions that may be invoked once the Promise is settled.\n *\n * @private @final @struct @constructor\n */\ngoog.Promise.CallbackEntry_ = function() {\n  /** @type {?goog.Promise} */\n  this.child = null;\n  /** @type {?Function} */\n  this.onFulfilled = null;\n  /** @type {?Function} */\n  this.onRejected = null;\n  /** @type {?} */\n  this.context = null;\n  /** @type {?goog.Promise.CallbackEntry_} */\n  this.next = null;\n\n  /**\n   * A boolean value to indicate this is a \"thenAlways\" callback entry.\n   * Unlike a normal \"then/thenVoid\" a \"thenAlways doesn't participate\n   * in \"cancel\" considerations but is simply an observer and requires\n   * special handling.\n   * @type {boolean}\n   */\n  this.always = false;\n};\n\n\n/** clear the object prior to reuse */\ngoog.Promise.CallbackEntry_.prototype.reset = function() {\n  this.child = null;\n  this.onFulfilled = null;\n  this.onRejected = null;\n  this.context = null;\n  this.always = false;\n};\n\n\n/**\n * @define {number} The number of currently unused objects to keep around for\n *    reuse.\n */\ngoog.Promise.DEFAULT_MAX_UNUSED =\n    goog.define('goog.Promise.DEFAULT_MAX_UNUSED', 100);\n\n\n/** @const @private {goog.async.FreeList<!goog.Promise.CallbackEntry_>} */\ngoog.Promise.freelist_ = new goog.async.FreeList(\n    function() { return new goog.Promise.CallbackEntry_(); },\n    function(item) { item.reset(); }, goog.Promise.DEFAULT_MAX_UNUSED);\n\n\n/**\n * @param {Function} onFulfilled\n * @param {Function} onRejected\n * @param {?} context\n * @return {!goog.Promise.CallbackEntry_}\n * @private\n */\ngoog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {\n  var entry = goog.Promise.freelist_.get();\n  entry.onFulfilled = onFulfilled;\n  entry.onRejected = onRejected;\n  entry.context = context;\n  return entry;\n};\n\n\n/**\n * @param {!goog.Promise.CallbackEntry_} entry\n * @private\n */\ngoog.Promise.returnEntry_ = function(entry) {\n  goog.Promise.freelist_.put(entry);\n};\n\n\n// NOTE: this is the same template expression as is used for\n// goog.IThenable.prototype.then\n\n\n/**\n * @param {VALUE=} opt_value\n * @return {RESULT} A new Promise that is immediately resolved\n *     with the given value. If the input value is already a goog.Promise, it\n *     will be returned immediately without creating a new instance.\n * @template VALUE\n * @template RESULT := type('goog.Promise',\n *     cond(isUnknown(VALUE), unknown(),\n *       mapunion(VALUE, (V) =>\n *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),\n *           templateTypeOf(V, 0),\n *           cond(sub(V, 'Thenable'),\n *              unknown(),\n *              V)))))\n * =:\n */\ngoog.Promise.resolve = function(opt_value) {\n  if (opt_value instanceof goog.Promise) {\n    // Avoid creating a new object if we already have a promise object\n    // of the correct type.\n    return opt_value;\n  }\n\n  // Passing goog.nullFunction will cause the constructor to take an optimized\n  // path that skips calling the resolver function.\n  var promise = new goog.Promise(goog.nullFunction);\n  promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);\n  return promise;\n};\n\n\n/**\n * @param {*=} opt_reason\n * @return {!goog.Promise} A new Promise that is immediately rejected with the\n *     given reason.\n */\ngoog.Promise.reject = function(opt_reason) {\n  return new goog.Promise(function(resolve, reject) { reject(opt_reason); });\n};\n\n\n/**\n * This is identical to\n * {@code goog.Promise.resolve(value).then(onFulfilled, onRejected)}, but it\n * avoids creating an unnecessary wrapper Promise when `value` is already\n * thenable.\n *\n * @param {?(goog.Thenable<TYPE>|Thenable|TYPE)} value\n * @param {function(TYPE): ?} onFulfilled\n * @param {function(*): *} onRejected\n * @template TYPE\n * @private\n */\ngoog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {\n  var isThenable =\n      goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);\n  if (!isThenable) {\n    goog.async.run(goog.partial(onFulfilled, value));\n  }\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<TYPE>} A Promise that receives the result of the\n *     first Promise (or Promise-like) input to settle immediately after it\n *     settles.\n * @template TYPE\n */\ngoog.Promise.race = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    if (!promises.length) {\n      resolve(undefined);\n    }\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, resolve, reject);\n    }\n  });\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<!Array<TYPE>>} A Promise that receives a list of\n *     every fulfilled value once every input Promise (or Promise-like) is\n *     successfully fulfilled, or is rejected with the first rejection reason\n *     immediately after it is rejected.\n * @template TYPE\n */\ngoog.Promise.all = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toFulfill = promises.length;\n    var values = [];\n\n    if (!toFulfill) {\n      resolve(values);\n      return;\n    }\n\n    var onFulfill = function(index, value) {\n      toFulfill--;\n      values[index] = value;\n      if (toFulfill == 0) {\n        resolve(values);\n      }\n    };\n\n    var onReject = function(reason) { reject(reason); };\n\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject);\n    }\n  });\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<!Array<{\n *     fulfilled: boolean,\n *     value: (TYPE|undefined),\n *     reason: (*|undefined)}>>} A Promise that resolves with a list of\n *         result objects once all input Promises (or Promise-like) have\n *         settled. Each result object contains a 'fulfilled' boolean indicating\n *         whether an input Promise was fulfilled or rejected. For fulfilled\n *         Promises, the resulting value is stored in the 'value' field. For\n *         rejected Promises, the rejection reason is stored in the 'reason'\n *         field.\n * @template TYPE\n */\ngoog.Promise.allSettled = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toSettle = promises.length;\n    var results = [];\n\n    if (!toSettle) {\n      resolve(results);\n      return;\n    }\n\n    var onSettled = function(index, fulfilled, result) {\n      toSettle--;\n      results[index] = fulfilled ? {fulfilled: true, value: result} :\n                                   {fulfilled: false, reason: result};\n      if (toSettle == 0) {\n        resolve(results);\n      }\n    };\n\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(\n          promise, goog.partial(onSettled, i, true /* fulfilled */),\n          goog.partial(onSettled, i, false /* fulfilled */));\n    }\n  });\n};\n\n\n/**\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\n *     promises\n * @return {!goog.Promise<TYPE>} A Promise that receives the value of the first\n *     input to be fulfilled, or is rejected with a list of every rejection\n *     reason if all inputs are rejected.\n * @template TYPE\n */\ngoog.Promise.firstFulfilled = function(promises) {\n  return new goog.Promise(function(resolve, reject) {\n    var toReject = promises.length;\n    var reasons = [];\n\n    if (!toReject) {\n      resolve(undefined);\n      return;\n    }\n\n    var onFulfill = function(value) { resolve(value); };\n\n    var onReject = function(index, reason) {\n      toReject--;\n      reasons[index] = reason;\n      if (toReject == 0) {\n        reject(reasons);\n      }\n    };\n\n    for (var i = 0, promise; i < promises.length; i++) {\n      promise = promises[i];\n      goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i));\n    }\n  });\n};\n\n\n/**\n * @return {!goog.promise.Resolver<TYPE>} Resolver wrapping the promise and its\n *     resolve / reject functions. Resolving or rejecting the resolver\n *     resolves or rejects the promise.\n * @template TYPE\n */\ngoog.Promise.withResolver = function() {\n  var resolve, reject;\n  var promise = new goog.Promise(function(rs, rj) {\n    resolve = rs;\n    reject = rj;\n  });\n  return new goog.Promise.Resolver_(promise, resolve, reject);\n};\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise, returning a\n * new child Promise.\n *\n * If the Promise is fulfilled, the `onFulfilled` callback will be invoked\n * with the fulfillment value as argument, and the child Promise will be\n * fulfilled with the return value of the callback. If the callback throws an\n * exception, the child Promise will be rejected with the thrown value instead.\n *\n * If the Promise is rejected, the `onRejected` callback will be invoked\n * with the rejection reason as argument, and the child Promise will be resolved\n * with the return value or rejected with the thrown value of the callback.\n *\n * @override\n */\ngoog.Promise.prototype.then = function(\n    opt_onFulfilled, opt_onRejected, opt_context) {\n\n  if (opt_onFulfilled != null) {\n    goog.asserts.assertFunction(\n        opt_onFulfilled, 'opt_onFulfilled should be a function.');\n  }\n  if (opt_onRejected != null) {\n    goog.asserts.assertFunction(\n        opt_onRejected,\n        'opt_onRejected should be a function. Did you pass opt_context ' +\n            'as the second argument instead of the third?');\n  }\n\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('then'));\n  }\n\n  return this.addChildPromise_(\n      goog.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,\n      goog.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);\n};\ngoog.Thenable.addImplementation(goog.Promise);\n\n\n/**\n * Adds callbacks that will operate on the result of the Promise without\n * returning a child Promise (unlike \"then\").\n *\n * If the Promise is fulfilled, the `onFulfilled` callback will be invoked\n * with the fulfillment value as argument.\n *\n * If the Promise is rejected, the `onRejected` callback will be invoked\n * with the rejection reason as argument.\n *\n * @param {?(function(this:THIS, TYPE):?)=} opt_onFulfilled A\n *     function that will be invoked with the fulfillment value if the Promise\n *     is fulfilled.\n * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will\n *     be invoked with the rejection reason if the Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     with the default this.\n * @package\n * @template THIS\n */\ngoog.Promise.prototype.thenVoid = function(\n    opt_onFulfilled, opt_onRejected, opt_context) {\n\n  if (opt_onFulfilled != null) {\n    goog.asserts.assertFunction(\n        opt_onFulfilled, 'opt_onFulfilled should be a function.');\n  }\n  if (opt_onRejected != null) {\n    goog.asserts.assertFunction(\n        opt_onRejected,\n        'opt_onRejected should be a function. Did you pass opt_context ' +\n            'as the second argument instead of the third?');\n  }\n\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('then'));\n  }\n\n  // Note: no default rejection handler is provided here as we need to\n  // distinguish unhandled rejections.\n  this.addCallbackEntry_(\n      goog.Promise.getCallbackEntry_(\n          opt_onFulfilled || goog.nullFunction, opt_onRejected || null,\n          opt_context));\n};\n\n\n/**\n * Adds a callback that will be invoked when the Promise is settled (fulfilled\n * or rejected). The callback receives no argument, and no new child Promise is\n * created. This is useful for ensuring that cleanup takes place after certain\n * asynchronous operations. Callbacks added with `thenAlways` will be\n * executed in the same order with other calls to `then`,\n * `thenAlways`, or `thenCatch`.\n *\n * Since it does not produce a new child Promise, cancellation propagation is\n * not prevented by adding callbacks with `thenAlways`. A Promise that has\n * a cleanup handler added with `thenAlways` will be canceled if all of\n * its children created by `then` (or `thenCatch`) are canceled.\n * Additionally, since any rejections are not passed to the callback, it does\n * not stop the unhandled rejection handler from running.\n *\n * @param {function(this:THIS): void} onSettled A function that will be invoked\n *     when the Promise is settled (fulfilled or rejected).\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!goog.Promise<TYPE>} This Promise, for chaining additional calls.\n * @template THIS\n */\ngoog.Promise.prototype.thenAlways = function(onSettled, opt_context) {\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('thenAlways'));\n  }\n\n  var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);\n  entry.always = true;\n  this.addCallbackEntry_(entry);\n  return this;\n};\n\n\n/**\n * Adds a callback that will be invoked only if the Promise is rejected. This\n * is equivalent to `then(null, onRejected)`.\n *\n * @param {function(this:THIS, *): *} onRejected A function that will be\n *     invoked with the rejection reason if this Promise is rejected.\n * @param {THIS=} opt_context An optional context object that will be the\n *     execution context for the callbacks. By default, functions are executed\n *     in the global scope.\n * @return {!goog.Promise} A new Promise that will resolve either to the\n *     value of this promise, or if this promise is rejected, the result of\n *     `onRejected`. The returned Promise will reject if `onRejected` throws.\n * @template THIS\n */\ngoog.Promise.prototype.thenCatch = function(onRejected, opt_context) {\n  if (goog.Promise.LONG_STACK_TRACES) {\n    this.addStackTrace_(new Error('thenCatch'));\n  }\n  return this.addChildPromise_(null, onRejected, opt_context);\n};\n\n\n/**\n * Cancels the Promise if it is still pending by rejecting it with a cancel\n * Error. No action is performed if the Promise is already resolved.\n *\n * All child Promises of the canceled Promise will be rejected with the same\n * cancel error, as with normal Promise rejection. If the Promise to be canceled\n * is the only child of a pending Promise, the parent Promise will also be\n * canceled. Cancellation may propagate upward through multiple generations.\n *\n * @param {string=} opt_message An optional debugging message for describing the\n *     cancellation reason.\n */\ngoog.Promise.prototype.cancel = function(opt_message) {\n  if (this.state_ == goog.Promise.State_.PENDING) {\n    // Instantiate Error object synchronously. This ensures Error::stack points\n    // to the cancel() callsite.\n    var err = new goog.Promise.CancellationError(opt_message);\n    goog.async.run(function() {\n      this.cancelInternal_(err);\n    }, this);\n  }\n};\n\n\n/**\n * Cancels this Promise with the given error.\n *\n * @param {!Error} err The cancellation error.\n * @private\n */\ngoog.Promise.prototype.cancelInternal_ = function(err) {\n  if (this.state_ == goog.Promise.State_.PENDING) {\n    if (this.parent_) {\n      // Cancel the Promise and remove it from the parent's child list.\n      this.parent_.cancelChild_(this, err);\n      this.parent_ = null;\n    } else {\n      this.resolve_(goog.Promise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Cancels a child Promise from the list of callback entries. If the Promise has\n * not already been resolved, reject it with a cancel error. If there are no\n * other children in the list of callback entries, propagate the cancellation\n * by canceling this Promise as well.\n *\n * @param {!goog.Promise} childPromise The Promise to cancel.\n * @param {!Error} err The cancel error to use for rejecting the Promise.\n * @private\n */\ngoog.Promise.prototype.cancelChild_ = function(childPromise, err) {\n  if (!this.callbackEntries_) {\n    return;\n  }\n  var childCount = 0;\n  var childEntry = null;\n  var beforeChildEntry = null;\n\n  // Find the callback entry for the childPromise, and count whether there are\n  // additional child Promises.\n  for (var entry = this.callbackEntries_; entry; entry = entry.next) {\n    if (!entry.always) {\n      childCount++;\n      if (entry.child == childPromise) {\n        childEntry = entry;\n      }\n      if (childEntry && childCount > 1) {\n        break;\n      }\n    }\n    if (!childEntry) {\n      beforeChildEntry = entry;\n    }\n  }\n\n  // Can a child entry be missing?\n\n  // If the child Promise was the only child, cancel this Promise as well.\n  // Otherwise, reject only the child Promise with the cancel error.\n  if (childEntry) {\n    if (this.state_ == goog.Promise.State_.PENDING && childCount == 1) {\n      this.cancelInternal_(err);\n    } else {\n      if (beforeChildEntry) {\n        this.removeEntryAfter_(beforeChildEntry);\n      } else {\n        this.popEntry_();\n      }\n\n      this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err);\n    }\n  }\n};\n\n\n/**\n * Adds a callback entry to the current Promise, and schedules callback\n * execution if the Promise has already been settled.\n *\n * @param {goog.Promise.CallbackEntry_} callbackEntry Record containing\n *     `onFulfilled` and `onRejected` callbacks to execute after\n *     the Promise is settled.\n * @private\n */\ngoog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {\n  if (!this.hasEntry_() && (this.state_ == goog.Promise.State_.FULFILLED ||\n                            this.state_ == goog.Promise.State_.REJECTED)) {\n    this.scheduleCallbacks_();\n  }\n  this.queueEntry_(callbackEntry);\n};\n\n\n/**\n * Creates a child Promise and adds it to the callback entry list. The result of\n * the child Promise is determined by the state of the parent Promise and the\n * result of the `onFulfilled` or `onRejected` callbacks as\n * specified in the Promise resolution procedure.\n *\n * @see http://promisesaplus.com/#the__method\n *\n * @param {?function(this:THIS, TYPE):\n *          (RESULT|goog.Promise<RESULT>|Thenable)} onFulfilled A callback that\n *     will be invoked if the Promise is fulfilled, or null.\n * @param {?function(this:THIS, *): *} onRejected A callback that will be\n *     invoked if the Promise is rejected, or null.\n * @param {THIS=} opt_context An optional execution context for the callbacks.\n *     in the default calling context.\n * @return {!goog.Promise} The child Promise.\n * @template RESULT,THIS\n * @private\n */\ngoog.Promise.prototype.addChildPromise_ = function(\n    onFulfilled, onRejected, opt_context) {\n\n  /** @type {goog.Promise.CallbackEntry_} */\n  var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);\n\n  callbackEntry.child = new goog.Promise(function(resolve, reject) {\n    // Invoke onFulfilled, or resolve with the parent's value if absent.\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\n      try {\n        var result = onFulfilled.call(opt_context, value);\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    } : resolve;\n\n    // Invoke onRejected, or reject with the parent's reason if absent.\n    callbackEntry.onRejected = onRejected ? function(reason) {\n      try {\n        var result = onRejected.call(opt_context, reason);\n        if (result === undefined &&\n            reason instanceof goog.Promise.CancellationError) {\n          // Propagate cancellation to children if no other result is returned.\n          reject(reason);\n        } else {\n          resolve(result);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    } : reject;\n  });\n\n  callbackEntry.child.parent_ = this;\n  this.addCallbackEntry_(callbackEntry);\n  return callbackEntry.child;\n};\n\n\n/**\n * Unblocks the Promise and fulfills it with the given value.\n *\n * @param {TYPE} value\n * @private\n */\ngoog.Promise.prototype.unblockAndFulfill_ = function(value) {\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\n  this.state_ = goog.Promise.State_.PENDING;\n  this.resolve_(goog.Promise.State_.FULFILLED, value);\n};\n\n\n/**\n * Unblocks the Promise and rejects it with the given rejection reason.\n *\n * @param {*} reason\n * @private\n */\ngoog.Promise.prototype.unblockAndReject_ = function(reason) {\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\n  this.state_ = goog.Promise.State_.PENDING;\n  this.resolve_(goog.Promise.State_.REJECTED, reason);\n};\n\n\n/**\n * Attempts to resolve a Promise with a given resolution state and value. This\n * is a no-op if the given Promise has already been resolved.\n *\n * If the given result is a Thenable (such as another Promise), the Promise will\n * be settled with the same state and result as the Thenable once it is itself\n * settled.\n *\n * If the given result is not a Thenable, the Promise will be settled (fulfilled\n * or rejected) with that result based on the given state.\n *\n * @see http://promisesaplus.com/#the_promise_resolution_procedure\n *\n * @param {goog.Promise.State_} state\n * @param {*} x The result to apply to the Promise.\n * @private\n */\ngoog.Promise.prototype.resolve_ = function(state, x) {\n  if (this.state_ != goog.Promise.State_.PENDING) {\n    return;\n  }\n\n  if (this === x) {\n    state = goog.Promise.State_.REJECTED;\n    x = new TypeError('Promise cannot resolve to itself');\n  }\n\n  this.state_ = goog.Promise.State_.BLOCKED;\n  var isThenable = goog.Promise.maybeThen_(\n      x, this.unblockAndFulfill_, this.unblockAndReject_, this);\n  if (isThenable) {\n    return;\n  }\n\n  this.result_ = x;\n  this.state_ = state;\n  // Since we can no longer be canceled, remove link to parent, so that the\n  // child promise does not keep the parent promise alive.\n  this.parent_ = null;\n  this.scheduleCallbacks_();\n\n  if (state == goog.Promise.State_.REJECTED &&\n      !(x instanceof goog.Promise.CancellationError)) {\n    goog.Promise.addUnhandledRejection_(this, x);\n  }\n};\n\n\n/**\n * Invokes the \"then\" method of an input value if that value is a Thenable. This\n * is a no-op if the value is not thenable.\n *\n * @param {?} value A potentially thenable value.\n * @param {!Function} onFulfilled\n * @param {!Function} onRejected\n * @param {?} context\n * @return {boolean} Whether the input value was thenable.\n * @private\n */\ngoog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {\n  if (value instanceof goog.Promise) {\n    value.thenVoid(onFulfilled, onRejected, context);\n    return true;\n  } else if (goog.Thenable.isImplementedBy(value)) {\n    value = /** @type {!goog.Thenable} */ (value);\n    value.then(onFulfilled, onRejected, context);\n    return true;\n  } else if (goog.isObject(value)) {\n    try {\n      var then = value['then'];\n      if (goog.isFunction(then)) {\n        goog.Promise.tryThen_(value, then, onFulfilled, onRejected, context);\n        return true;\n      }\n    } catch (e) {\n      onRejected.call(context, e);\n      return true;\n    }\n  }\n\n  return false;\n};\n\n\n/**\n * Attempts to call the `then` method on an object in the hopes that it is\n * a Promise-compatible instance. This allows interoperation between different\n * Promise implementations, however a non-compliant object may cause a Promise\n * to hang indefinitely. If the `then` method throws an exception, the\n * dependent Promise will be rejected with the thrown value.\n *\n * @see http://promisesaplus.com/#point-70\n *\n * @param {Thenable} thenable An object with a `then` method that may be\n *     compatible with the Promise/A+ specification.\n * @param {!Function} then The `then` method of the Thenable object.\n * @param {!Function} onFulfilled\n * @param {!Function} onRejected\n * @param {*} context\n * @private\n */\ngoog.Promise.tryThen_ = function(\n    thenable, then, onFulfilled, onRejected, context) {\n\n  var called = false;\n  var resolve = function(value) {\n    if (!called) {\n      called = true;\n      onFulfilled.call(context, value);\n    }\n  };\n\n  var reject = function(reason) {\n    if (!called) {\n      called = true;\n      onRejected.call(context, reason);\n    }\n  };\n\n  try {\n    then.call(thenable, resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n};\n\n\n/**\n * Executes the pending callbacks of a settled Promise after a timeout.\n *\n * Section 2.2.4 of the Promises/A+ specification requires that Promise\n * callbacks must only be invoked from a call stack that only contains Promise\n * implementation code, which we accomplish by invoking callback execution after\n * a timeout. If `startExecution_` is called multiple times for the same\n * Promise, the callback chain will be evaluated only once. Additional callbacks\n * may be added during the evaluation phase, and will be executed in the same\n * event loop.\n *\n * All Promises added to the waiting list during the same browser event loop\n * will be executed in one batch to avoid using a separate timeout per Promise.\n *\n * @private\n */\ngoog.Promise.prototype.scheduleCallbacks_ = function() {\n  if (!this.executing_) {\n    this.executing_ = true;\n    goog.async.run(this.executeCallbacks_, this);\n  }\n};\n\n\n/**\n * @return {boolean} Whether there are any pending callbacks queued.\n * @private\n */\ngoog.Promise.prototype.hasEntry_ = function() {\n  return !!this.callbackEntries_;\n};\n\n\n/**\n * @param {goog.Promise.CallbackEntry_} entry\n * @private\n */\ngoog.Promise.prototype.queueEntry_ = function(entry) {\n  goog.asserts.assert(entry.onFulfilled != null);\n\n  if (this.callbackEntriesTail_) {\n    this.callbackEntriesTail_.next = entry;\n    this.callbackEntriesTail_ = entry;\n  } else {\n    // It the work queue was empty set the head too.\n    this.callbackEntries_ = entry;\n    this.callbackEntriesTail_ = entry;\n  }\n};\n\n\n/**\n * @return {goog.Promise.CallbackEntry_} entry\n * @private\n */\ngoog.Promise.prototype.popEntry_ = function() {\n  var entry = null;\n  if (this.callbackEntries_) {\n    entry = this.callbackEntries_;\n    this.callbackEntries_ = entry.next;\n    entry.next = null;\n  }\n  // It the work queue is empty clear the tail too.\n  if (!this.callbackEntries_) {\n    this.callbackEntriesTail_ = null;\n  }\n\n  if (entry != null) {\n    goog.asserts.assert(entry.onFulfilled != null);\n  }\n  return entry;\n};\n\n\n/**\n * @param {goog.Promise.CallbackEntry_} previous\n * @private\n */\ngoog.Promise.prototype.removeEntryAfter_ = function(previous) {\n  goog.asserts.assert(this.callbackEntries_);\n  goog.asserts.assert(previous != null);\n  // If the last entry is being removed, update the tail\n  if (previous.next == this.callbackEntriesTail_) {\n    this.callbackEntriesTail_ = previous;\n  }\n\n  previous.next = previous.next.next;\n};\n\n\n/**\n * Executes all pending callbacks for this Promise.\n *\n * @private\n */\ngoog.Promise.prototype.executeCallbacks_ = function() {\n  var entry = null;\n  while (entry = this.popEntry_()) {\n    if (goog.Promise.LONG_STACK_TRACES) {\n      this.currentStep_++;\n    }\n    this.executeCallback_(entry, this.state_, this.result_);\n  }\n  this.executing_ = false;\n};\n\n\n/**\n * Executes a pending callback for this Promise. Invokes an `onFulfilled`\n * or `onRejected` callback based on the settled state of the Promise.\n *\n * @param {!goog.Promise.CallbackEntry_} callbackEntry An entry containing the\n *     onFulfilled and/or onRejected callbacks for this step.\n * @param {goog.Promise.State_} state The resolution status of the Promise,\n *     either FULFILLED or REJECTED.\n * @param {*} result The settled result of the Promise.\n * @private\n */\ngoog.Promise.prototype.executeCallback_ = function(\n    callbackEntry, state, result) {\n  // Cancel an unhandled rejection if the then/thenVoid call had an onRejected.\n  if (state == goog.Promise.State_.REJECTED && callbackEntry.onRejected &&\n      !callbackEntry.always) {\n    this.removeUnhandledRejection_();\n  }\n\n  if (callbackEntry.child) {\n    // When the parent is settled, the child no longer needs to hold on to it,\n    // as the parent can no longer be canceled.\n    callbackEntry.child.parent_ = null;\n    goog.Promise.invokeCallback_(callbackEntry, state, result);\n  } else {\n    // Callbacks created with thenAlways or thenVoid do not have the rejection\n    // handling code normally set up in the child Promise.\n    try {\n      callbackEntry.always ?\n          callbackEntry.onFulfilled.call(callbackEntry.context) :\n          goog.Promise.invokeCallback_(callbackEntry, state, result);\n    } catch (err) {\n      goog.Promise.handleRejection_.call(null, err);\n    }\n  }\n  goog.Promise.returnEntry_(callbackEntry);\n};\n\n\n/**\n * Executes the onFulfilled or onRejected callback for a callbackEntry.\n *\n * @param {!goog.Promise.CallbackEntry_} callbackEntry\n * @param {goog.Promise.State_} state\n * @param {*} result\n * @private\n */\ngoog.Promise.invokeCallback_ = function(callbackEntry, state, result) {\n  if (state == goog.Promise.State_.FULFILLED) {\n    callbackEntry.onFulfilled.call(callbackEntry.context, result);\n  } else if (callbackEntry.onRejected) {\n    callbackEntry.onRejected.call(callbackEntry.context, result);\n  }\n};\n\n\n/**\n * Records a stack trace entry for functions that call `then` or the\n * Promise constructor. May be disabled by unsetting `LONG_STACK_TRACES`.\n *\n * @param {!Error} err An Error object created by the calling function for\n *     providing a stack trace.\n * @private\n */\ngoog.Promise.prototype.addStackTrace_ = function(err) {\n  if (goog.Promise.LONG_STACK_TRACES && typeof err.stack === 'string') {\n    // Extract the third line of the stack trace, which is the entry for the\n    // user function that called into Promise code.\n    var trace = err.stack.split('\\n', 4)[3];\n    var message = err.message;\n\n    // Pad the message to align the traces.\n    message += Array(11 - message.length).join(' ');\n    this.stack_.push(message + trace);\n  }\n};\n\n\n/**\n * Adds extra stack trace information to an exception for the list of\n * asynchronous `then` calls that have been run for this Promise. Stack\n * trace information is recorded in {@see #addStackTrace_}, and appended to\n * rethrown errors when `LONG_STACK_TRACES` is enabled.\n *\n * @param {?} err An unhandled exception captured during callback execution.\n * @private\n */\ngoog.Promise.prototype.appendLongStack_ = function(err) {\n  if (goog.Promise.LONG_STACK_TRACES && err && typeof err.stack === 'string' &&\n      this.stack_.length) {\n    var longTrace = ['Promise trace:'];\n\n    for (var promise = this; promise; promise = promise.parent_) {\n      for (var i = this.currentStep_; i >= 0; i--) {\n        longTrace.push(promise.stack_[i]);\n      }\n      longTrace.push(\n          'Value: ' +\n          '[' + (promise.state_ == goog.Promise.State_.REJECTED ? 'REJECTED' :\n                                                                  'FULFILLED') +\n          '] ' +\n          '<' + String(promise.result_) + '>');\n    }\n    err.stack += '\\n\\n' + longTrace.join('\\n');\n  }\n};\n\n\n/**\n * Marks this rejected Promise as having being handled. Also marks any parent\n * Promises in the rejected state as handled. The rejection handler will no\n * longer be invoked for this Promise (if it has not been called already).\n *\n * @private\n */\ngoog.Promise.prototype.removeUnhandledRejection_ = function() {\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {\n      goog.global.clearTimeout(p.unhandledRejectionId_);\n      p.unhandledRejectionId_ = 0;\n    }\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n    for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\n      p.hadUnhandledRejection_ = false;\n    }\n  }\n};\n\n\n/**\n * Marks this rejected Promise as unhandled. If no `onRejected` callback\n * is called for this Promise before the `UNHANDLED_REJECTION_DELAY`\n * expires, the reason will be passed to the unhandled rejection handler. The\n * handler typically rethrows the rejection reason so that it becomes visible in\n * the developer console.\n *\n * @param {!goog.Promise} promise The rejected Promise.\n * @param {*} reason The Promise rejection reason.\n * @private\n */\ngoog.Promise.addUnhandledRejection_ = function(promise, reason) {\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\n    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {\n      promise.appendLongStack_(reason);\n      goog.Promise.handleRejection_.call(null, reason);\n    }, goog.Promise.UNHANDLED_REJECTION_DELAY);\n\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\n    promise.hadUnhandledRejection_ = true;\n    goog.async.run(function() {\n      if (promise.hadUnhandledRejection_) {\n        promise.appendLongStack_(reason);\n        goog.Promise.handleRejection_.call(null, reason);\n      }\n    });\n  }\n};\n\n\n/**\n * A method that is invoked with the rejection reasons for Promises that are\n * rejected but have no `onRejected` callbacks registered yet.\n * @type {function(*)}\n * @private\n */\ngoog.Promise.handleRejection_ = goog.async.throwException;\n\n\n/**\n * Sets a handler that will be called with reasons from unhandled rejected\n * Promises. If the rejected Promise (or one of its descendants) has an\n * `onRejected` callback registered, the rejection will be considered\n * handled, and the rejection handler will not be called.\n *\n * By default, unhandled rejections are rethrown so that the error may be\n * captured by the developer console or a `window.onerror` handler.\n *\n * @param {function(*)} handler A function that will be called with reasons from\n *     rejected Promises. Defaults to `goog.async.throwException`.\n */\ngoog.Promise.setUnhandledRejectionHandler = function(handler) {\n  goog.Promise.handleRejection_ = handler;\n};\n\n\n\n/**\n * Error used as a rejection reason for canceled Promises.\n *\n * @param {string=} opt_message\n * @constructor\n * @extends {goog.debug.Error}\n * @final\n */\ngoog.Promise.CancellationError = function(opt_message) {\n  goog.Promise.CancellationError.base(this, 'constructor', opt_message);\n};\ngoog.inherits(goog.Promise.CancellationError, goog.debug.Error);\n\n\n/** @override */\ngoog.Promise.CancellationError.prototype.name = 'cancel';\n\n\n\n/**\n * Internal implementation of the resolver interface.\n *\n * @param {!goog.Promise<TYPE>} promise\n * @param {function((TYPE|goog.Promise<TYPE>|Thenable)=)} resolve\n * @param {function(*=): void} reject\n * @implements {goog.promise.Resolver<TYPE>}\n * @final @struct\n * @constructor\n * @private\n * @template TYPE\n */\ngoog.Promise.Resolver_ = function(promise, resolve, reject) {\n  /** @const */\n  this.promise = promise;\n\n  /** @const */\n  this.resolve = resolve;\n\n  /** @const */\n  this.reject = reject;\n};\n","~:compiled-at",1626505467985,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.promise.promise.js\",\n\"lineCount\":538,\n\"mappings\":\"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\",\n\"sources\":[\"goog/promise/promise.js\"],\n\"sourcesContent\":[\"// Copyright 2013 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\ngoog.provide('goog.Promise');\\n\\ngoog.require('goog.Thenable');\\ngoog.require('goog.asserts');\\ngoog.require('goog.async.FreeList');\\ngoog.require('goog.async.run');\\ngoog.require('goog.async.throwException');\\ngoog.require('goog.debug.Error');\\ngoog.require('goog.promise.Resolver');\\n\\n\\n\\n/**\\n * NOTE: This class was created in anticipation of the built-in Promise type\\n * being standardized and implemented across browsers. Now that Promise is\\n * available in modern browsers, and is automatically polyfilled by the Closure\\n * Compiler, by default, most new code should use native `Promise`\\n * instead of `goog.Promise`. However, `goog.Promise` has the\\n * concept of cancellation which native Promises do not yet have. So code\\n * needing cancellation may still want to use `goog.Promise`.\\n *\\n * Promises provide a result that may be resolved asynchronously. A Promise may\\n * be resolved by being fulfilled with a fulfillment value, rejected with a\\n * rejection reason, or blocked by another Promise. A Promise is said to be\\n * settled if it is either fulfilled or rejected. Once settled, the Promise\\n * result is immutable.\\n *\\n * Promises may represent results of any type, including undefined. Rejection\\n * reasons are typically Errors, but may also be of any type. Closure Promises\\n * allow for optional type annotations that enforce that fulfillment values are\\n * of the appropriate types at compile time.\\n *\\n * The result of a Promise is accessible by calling `then` and registering\\n * `onFulfilled` and `onRejected` callbacks. Once the Promise\\n * is settled, the relevant callbacks are invoked with the fulfillment value or\\n * rejection reason as argument. Callbacks are always invoked in the order they\\n * were registered, even when additional `then` calls are made from inside\\n * another callback. A callback is always run asynchronously sometime after the\\n * scope containing the registering `then` invocation has returned.\\n *\\n * If a Promise is resolved with another Promise, the first Promise will block\\n * until the second is settled, and then assumes the same result as the second\\n * Promise. This allows Promises to depend on the results of other Promises,\\n * linking together multiple asynchronous operations.\\n *\\n * This implementation is compatible with the Promises/A+ specification and\\n * passes that specification's conformance test suite. A Closure Promise may be\\n * resolved with a Promise instance (or sufficiently compatible Promise-like\\n * object) created by other Promise implementations. From the specification,\\n * Promise-like objects are known as \\\"Thenables\\\".\\n *\\n * @see http://promisesaplus.com/\\n *\\n * @param {function(\\n *             this:RESOLVER_CONTEXT,\\n *             function((TYPE|IThenable<TYPE>|Thenable)=),\\n *             function(*=)): void} resolver\\n *     Initialization function that is invoked immediately with `resolve`\\n *     and `reject` functions as arguments. The Promise is resolved or\\n *     rejected with the first argument passed to either function.\\n * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the\\n *     resolver function. If unspecified, the resolver function will be executed\\n *     in the default scope.\\n * @constructor\\n * @struct\\n * @final\\n * @implements {goog.Thenable<TYPE>}\\n * @template TYPE,RESOLVER_CONTEXT\\n */\\ngoog.Promise = function(resolver, opt_context) {\\n  /**\\n   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or\\n   * BLOCKED.\\n   * @private {goog.Promise.State_}\\n   */\\n  this.state_ = goog.Promise.State_.PENDING;\\n\\n  /**\\n   * The settled result of the Promise. Immutable once set with either a\\n   * fulfillment value or rejection reason.\\n   * @private {*}\\n   */\\n  this.result_ = undefined;\\n\\n  /**\\n   * For Promises created by calling `then()`, the originating parent.\\n   * @private {?goog.Promise}\\n   */\\n  this.parent_ = null;\\n\\n  /**\\n   * The linked list of `onFulfilled` and `onRejected` callbacks\\n   * added to this Promise by calls to `then()`.\\n   * @private {?goog.Promise.CallbackEntry_}\\n   */\\n  this.callbackEntries_ = null;\\n\\n  /**\\n   * The tail of the linked list of `onFulfilled` and `onRejected`\\n   * callbacks added to this Promise by calls to `then()`.\\n   * @private {?goog.Promise.CallbackEntry_}\\n   */\\n  this.callbackEntriesTail_ = null;\\n\\n  /**\\n   * Whether the Promise is in the queue of Promises to execute.\\n   * @private {boolean}\\n   */\\n  this.executing_ = false;\\n\\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\\n    /**\\n     * A timeout ID used when the `UNHANDLED_REJECTION_DELAY` is greater\\n     * than 0 milliseconds. The ID is set when the Promise is rejected, and\\n     * cleared only if an `onRejected` callback is invoked for the\\n     * Promise (or one of its descendants) before the delay is exceeded.\\n     *\\n     * If the rejection is not handled before the timeout completes, the\\n     * rejection reason is passed to the unhandled rejection handler.\\n     * @private {number}\\n     */\\n    this.unhandledRejectionId_ = 0;\\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\\n    /**\\n     * When the `UNHANDLED_REJECTION_DELAY` is set to 0 milliseconds, a\\n     * boolean that is set if the Promise is rejected, and reset to false if an\\n     * `onRejected` callback is invoked for the Promise (or one of its\\n     * descendants). If the rejection is not handled before the next timestep,\\n     * the rejection reason is passed to the unhandled rejection handler.\\n     * @private {boolean}\\n     */\\n    this.hadUnhandledRejection_ = false;\\n  }\\n\\n  if (goog.Promise.LONG_STACK_TRACES) {\\n    /**\\n     * A list of stack trace frames pointing to the locations where this Promise\\n     * was created or had callbacks added to it. Saved to add additional context\\n     * to stack traces when an exception is thrown.\\n     * @private {!Array<string>}\\n     */\\n    this.stack_ = [];\\n    this.addStackTrace_(new Error('created'));\\n\\n    /**\\n     * Index of the most recently executed stack frame entry.\\n     * @private {number}\\n     */\\n    this.currentStep_ = 0;\\n  }\\n\\n  // As an optimization, we can skip this if resolver is goog.nullFunction.\\n  // This value is passed internally when creating a promise which will be\\n  // resolved through a more optimized path.\\n  if (resolver != goog.nullFunction) {\\n    try {\\n      var self = this;\\n      resolver.call(\\n          opt_context,\\n          function(value) {\\n            self.resolve_(goog.Promise.State_.FULFILLED, value);\\n          },\\n          function(reason) {\\n            if (goog.DEBUG &&\\n                !(reason instanceof goog.Promise.CancellationError)) {\\n              try {\\n                // Promise was rejected. Step up one call frame to see why.\\n                if (reason instanceof Error) {\\n                  throw reason;\\n                } else {\\n                  throw new Error('Promise rejected.');\\n                }\\n              } catch (e) {\\n                // Only thrown so browser dev tools can catch rejections of\\n                // promises when the option to break on caught exceptions is\\n                // activated.\\n              }\\n            }\\n            self.resolve_(goog.Promise.State_.REJECTED, reason);\\n          });\\n    } catch (e) {\\n      this.resolve_(goog.Promise.State_.REJECTED, e);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * @define {boolean} Whether traces of `then` calls should be included in\\n * exceptions thrown\\n */\\ngoog.Promise.LONG_STACK_TRACES =\\n    goog.define('goog.Promise.LONG_STACK_TRACES', false);\\n\\n\\n/**\\n * @define {number} The delay in milliseconds before a rejected Promise's reason\\n * is passed to the rejection handler. By default, the rejection handler\\n * rethrows the rejection reason so that it appears in the developer console or\\n * `window.onerror` handler.\\n *\\n * Rejections are rethrown as quickly as possible by default. A negative value\\n * disables rejection handling entirely.\\n */\\ngoog.Promise.UNHANDLED_REJECTION_DELAY =\\n    goog.define('goog.Promise.UNHANDLED_REJECTION_DELAY', 0);\\n\\n\\n/**\\n * The possible internal states for a Promise. These states are not directly\\n * observable to external callers.\\n * @enum {number}\\n * @private\\n */\\ngoog.Promise.State_ = {\\n  /** The Promise is waiting for resolution. */\\n  PENDING: 0,\\n\\n  /** The Promise is blocked waiting for the result of another Thenable. */\\n  BLOCKED: 1,\\n\\n  /** The Promise has been resolved with a fulfillment value. */\\n  FULFILLED: 2,\\n\\n  /** The Promise has been resolved with a rejection reason. */\\n  REJECTED: 3\\n};\\n\\n\\n\\n/**\\n * Entries in the callback chain. Each call to `then`,\\n * `thenCatch`, or `thenAlways` creates an entry containing the\\n * functions that may be invoked once the Promise is settled.\\n *\\n * @private @final @struct @constructor\\n */\\ngoog.Promise.CallbackEntry_ = function() {\\n  /** @type {?goog.Promise} */\\n  this.child = null;\\n  /** @type {?Function} */\\n  this.onFulfilled = null;\\n  /** @type {?Function} */\\n  this.onRejected = null;\\n  /** @type {?} */\\n  this.context = null;\\n  /** @type {?goog.Promise.CallbackEntry_} */\\n  this.next = null;\\n\\n  /**\\n   * A boolean value to indicate this is a \\\"thenAlways\\\" callback entry.\\n   * Unlike a normal \\\"then/thenVoid\\\" a \\\"thenAlways doesn't participate\\n   * in \\\"cancel\\\" considerations but is simply an observer and requires\\n   * special handling.\\n   * @type {boolean}\\n   */\\n  this.always = false;\\n};\\n\\n\\n/** clear the object prior to reuse */\\ngoog.Promise.CallbackEntry_.prototype.reset = function() {\\n  this.child = null;\\n  this.onFulfilled = null;\\n  this.onRejected = null;\\n  this.context = null;\\n  this.always = false;\\n};\\n\\n\\n/**\\n * @define {number} The number of currently unused objects to keep around for\\n *    reuse.\\n */\\ngoog.Promise.DEFAULT_MAX_UNUSED =\\n    goog.define('goog.Promise.DEFAULT_MAX_UNUSED', 100);\\n\\n\\n/** @const @private {goog.async.FreeList<!goog.Promise.CallbackEntry_>} */\\ngoog.Promise.freelist_ = new goog.async.FreeList(\\n    function() { return new goog.Promise.CallbackEntry_(); },\\n    function(item) { item.reset(); }, goog.Promise.DEFAULT_MAX_UNUSED);\\n\\n\\n/**\\n * @param {Function} onFulfilled\\n * @param {Function} onRejected\\n * @param {?} context\\n * @return {!goog.Promise.CallbackEntry_}\\n * @private\\n */\\ngoog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {\\n  var entry = goog.Promise.freelist_.get();\\n  entry.onFulfilled = onFulfilled;\\n  entry.onRejected = onRejected;\\n  entry.context = context;\\n  return entry;\\n};\\n\\n\\n/**\\n * @param {!goog.Promise.CallbackEntry_} entry\\n * @private\\n */\\ngoog.Promise.returnEntry_ = function(entry) {\\n  goog.Promise.freelist_.put(entry);\\n};\\n\\n\\n// NOTE: this is the same template expression as is used for\\n// goog.IThenable.prototype.then\\n\\n\\n/**\\n * @param {VALUE=} opt_value\\n * @return {RESULT} A new Promise that is immediately resolved\\n *     with the given value. If the input value is already a goog.Promise, it\\n *     will be returned immediately without creating a new instance.\\n * @template VALUE\\n * @template RESULT := type('goog.Promise',\\n *     cond(isUnknown(VALUE), unknown(),\\n *       mapunion(VALUE, (V) =>\\n *         cond(isTemplatized(V) && sub(rawTypeOf(V), 'IThenable'),\\n *           templateTypeOf(V, 0),\\n *           cond(sub(V, 'Thenable'),\\n *              unknown(),\\n *              V)))))\\n * =:\\n */\\ngoog.Promise.resolve = function(opt_value) {\\n  if (opt_value instanceof goog.Promise) {\\n    // Avoid creating a new object if we already have a promise object\\n    // of the correct type.\\n    return opt_value;\\n  }\\n\\n  // Passing goog.nullFunction will cause the constructor to take an optimized\\n  // path that skips calling the resolver function.\\n  var promise = new goog.Promise(goog.nullFunction);\\n  promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);\\n  return promise;\\n};\\n\\n\\n/**\\n * @param {*=} opt_reason\\n * @return {!goog.Promise} A new Promise that is immediately rejected with the\\n *     given reason.\\n */\\ngoog.Promise.reject = function(opt_reason) {\\n  return new goog.Promise(function(resolve, reject) { reject(opt_reason); });\\n};\\n\\n\\n/**\\n * This is identical to\\n * {@code goog.Promise.resolve(value).then(onFulfilled, onRejected)}, but it\\n * avoids creating an unnecessary wrapper Promise when `value` is already\\n * thenable.\\n *\\n * @param {?(goog.Thenable<TYPE>|Thenable|TYPE)} value\\n * @param {function(TYPE): ?} onFulfilled\\n * @param {function(*): *} onRejected\\n * @template TYPE\\n * @private\\n */\\ngoog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {\\n  var isThenable =\\n      goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);\\n  if (!isThenable) {\\n    goog.async.run(goog.partial(onFulfilled, value));\\n  }\\n};\\n\\n\\n/**\\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\\n *     promises\\n * @return {!goog.Promise<TYPE>} A Promise that receives the result of the\\n *     first Promise (or Promise-like) input to settle immediately after it\\n *     settles.\\n * @template TYPE\\n */\\ngoog.Promise.race = function(promises) {\\n  return new goog.Promise(function(resolve, reject) {\\n    if (!promises.length) {\\n      resolve(undefined);\\n    }\\n    for (var i = 0, promise; i < promises.length; i++) {\\n      promise = promises[i];\\n      goog.Promise.resolveThen_(promise, resolve, reject);\\n    }\\n  });\\n};\\n\\n\\n/**\\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\\n *     promises\\n * @return {!goog.Promise<!Array<TYPE>>} A Promise that receives a list of\\n *     every fulfilled value once every input Promise (or Promise-like) is\\n *     successfully fulfilled, or is rejected with the first rejection reason\\n *     immediately after it is rejected.\\n * @template TYPE\\n */\\ngoog.Promise.all = function(promises) {\\n  return new goog.Promise(function(resolve, reject) {\\n    var toFulfill = promises.length;\\n    var values = [];\\n\\n    if (!toFulfill) {\\n      resolve(values);\\n      return;\\n    }\\n\\n    var onFulfill = function(index, value) {\\n      toFulfill--;\\n      values[index] = value;\\n      if (toFulfill == 0) {\\n        resolve(values);\\n      }\\n    };\\n\\n    var onReject = function(reason) { reject(reason); };\\n\\n    for (var i = 0, promise; i < promises.length; i++) {\\n      promise = promises[i];\\n      goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject);\\n    }\\n  });\\n};\\n\\n\\n/**\\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\\n *     promises\\n * @return {!goog.Promise<!Array<{\\n *     fulfilled: boolean,\\n *     value: (TYPE|undefined),\\n *     reason: (*|undefined)}>>} A Promise that resolves with a list of\\n *         result objects once all input Promises (or Promise-like) have\\n *         settled. Each result object contains a 'fulfilled' boolean indicating\\n *         whether an input Promise was fulfilled or rejected. For fulfilled\\n *         Promises, the resulting value is stored in the 'value' field. For\\n *         rejected Promises, the rejection reason is stored in the 'reason'\\n *         field.\\n * @template TYPE\\n */\\ngoog.Promise.allSettled = function(promises) {\\n  return new goog.Promise(function(resolve, reject) {\\n    var toSettle = promises.length;\\n    var results = [];\\n\\n    if (!toSettle) {\\n      resolve(results);\\n      return;\\n    }\\n\\n    var onSettled = function(index, fulfilled, result) {\\n      toSettle--;\\n      results[index] = fulfilled ? {fulfilled: true, value: result} :\\n                                   {fulfilled: false, reason: result};\\n      if (toSettle == 0) {\\n        resolve(results);\\n      }\\n    };\\n\\n    for (var i = 0, promise; i < promises.length; i++) {\\n      promise = promises[i];\\n      goog.Promise.resolveThen_(\\n          promise, goog.partial(onSettled, i, true /* fulfilled */),\\n          goog.partial(onSettled, i, false /* fulfilled */));\\n    }\\n  });\\n};\\n\\n\\n/**\\n * @param {!Array<?(goog.Promise<TYPE>|goog.Thenable<TYPE>|Thenable|*)>}\\n *     promises\\n * @return {!goog.Promise<TYPE>} A Promise that receives the value of the first\\n *     input to be fulfilled, or is rejected with a list of every rejection\\n *     reason if all inputs are rejected.\\n * @template TYPE\\n */\\ngoog.Promise.firstFulfilled = function(promises) {\\n  return new goog.Promise(function(resolve, reject) {\\n    var toReject = promises.length;\\n    var reasons = [];\\n\\n    if (!toReject) {\\n      resolve(undefined);\\n      return;\\n    }\\n\\n    var onFulfill = function(value) { resolve(value); };\\n\\n    var onReject = function(index, reason) {\\n      toReject--;\\n      reasons[index] = reason;\\n      if (toReject == 0) {\\n        reject(reasons);\\n      }\\n    };\\n\\n    for (var i = 0, promise; i < promises.length; i++) {\\n      promise = promises[i];\\n      goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i));\\n    }\\n  });\\n};\\n\\n\\n/**\\n * @return {!goog.promise.Resolver<TYPE>} Resolver wrapping the promise and its\\n *     resolve / reject functions. Resolving or rejecting the resolver\\n *     resolves or rejects the promise.\\n * @template TYPE\\n */\\ngoog.Promise.withResolver = function() {\\n  var resolve, reject;\\n  var promise = new goog.Promise(function(rs, rj) {\\n    resolve = rs;\\n    reject = rj;\\n  });\\n  return new goog.Promise.Resolver_(promise, resolve, reject);\\n};\\n\\n\\n/**\\n * Adds callbacks that will operate on the result of the Promise, returning a\\n * new child Promise.\\n *\\n * If the Promise is fulfilled, the `onFulfilled` callback will be invoked\\n * with the fulfillment value as argument, and the child Promise will be\\n * fulfilled with the return value of the callback. If the callback throws an\\n * exception, the child Promise will be rejected with the thrown value instead.\\n *\\n * If the Promise is rejected, the `onRejected` callback will be invoked\\n * with the rejection reason as argument, and the child Promise will be resolved\\n * with the return value or rejected with the thrown value of the callback.\\n *\\n * @override\\n */\\ngoog.Promise.prototype.then = function(\\n    opt_onFulfilled, opt_onRejected, opt_context) {\\n\\n  if (opt_onFulfilled != null) {\\n    goog.asserts.assertFunction(\\n        opt_onFulfilled, 'opt_onFulfilled should be a function.');\\n  }\\n  if (opt_onRejected != null) {\\n    goog.asserts.assertFunction(\\n        opt_onRejected,\\n        'opt_onRejected should be a function. Did you pass opt_context ' +\\n            'as the second argument instead of the third?');\\n  }\\n\\n  if (goog.Promise.LONG_STACK_TRACES) {\\n    this.addStackTrace_(new Error('then'));\\n  }\\n\\n  return this.addChildPromise_(\\n      goog.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,\\n      goog.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);\\n};\\ngoog.Thenable.addImplementation(goog.Promise);\\n\\n\\n/**\\n * Adds callbacks that will operate on the result of the Promise without\\n * returning a child Promise (unlike \\\"then\\\").\\n *\\n * If the Promise is fulfilled, the `onFulfilled` callback will be invoked\\n * with the fulfillment value as argument.\\n *\\n * If the Promise is rejected, the `onRejected` callback will be invoked\\n * with the rejection reason as argument.\\n *\\n * @param {?(function(this:THIS, TYPE):?)=} opt_onFulfilled A\\n *     function that will be invoked with the fulfillment value if the Promise\\n *     is fulfilled.\\n * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will\\n *     be invoked with the rejection reason if the Promise is rejected.\\n * @param {THIS=} opt_context An optional context object that will be the\\n *     execution context for the callbacks. By default, functions are executed\\n *     with the default this.\\n * @package\\n * @template THIS\\n */\\ngoog.Promise.prototype.thenVoid = function(\\n    opt_onFulfilled, opt_onRejected, opt_context) {\\n\\n  if (opt_onFulfilled != null) {\\n    goog.asserts.assertFunction(\\n        opt_onFulfilled, 'opt_onFulfilled should be a function.');\\n  }\\n  if (opt_onRejected != null) {\\n    goog.asserts.assertFunction(\\n        opt_onRejected,\\n        'opt_onRejected should be a function. Did you pass opt_context ' +\\n            'as the second argument instead of the third?');\\n  }\\n\\n  if (goog.Promise.LONG_STACK_TRACES) {\\n    this.addStackTrace_(new Error('then'));\\n  }\\n\\n  // Note: no default rejection handler is provided here as we need to\\n  // distinguish unhandled rejections.\\n  this.addCallbackEntry_(\\n      goog.Promise.getCallbackEntry_(\\n          opt_onFulfilled || goog.nullFunction, opt_onRejected || null,\\n          opt_context));\\n};\\n\\n\\n/**\\n * Adds a callback that will be invoked when the Promise is settled (fulfilled\\n * or rejected). The callback receives no argument, and no new child Promise is\\n * created. This is useful for ensuring that cleanup takes place after certain\\n * asynchronous operations. Callbacks added with `thenAlways` will be\\n * executed in the same order with other calls to `then`,\\n * `thenAlways`, or `thenCatch`.\\n *\\n * Since it does not produce a new child Promise, cancellation propagation is\\n * not prevented by adding callbacks with `thenAlways`. A Promise that has\\n * a cleanup handler added with `thenAlways` will be canceled if all of\\n * its children created by `then` (or `thenCatch`) are canceled.\\n * Additionally, since any rejections are not passed to the callback, it does\\n * not stop the unhandled rejection handler from running.\\n *\\n * @param {function(this:THIS): void} onSettled A function that will be invoked\\n *     when the Promise is settled (fulfilled or rejected).\\n * @param {THIS=} opt_context An optional context object that will be the\\n *     execution context for the callbacks. By default, functions are executed\\n *     in the global scope.\\n * @return {!goog.Promise<TYPE>} This Promise, for chaining additional calls.\\n * @template THIS\\n */\\ngoog.Promise.prototype.thenAlways = function(onSettled, opt_context) {\\n  if (goog.Promise.LONG_STACK_TRACES) {\\n    this.addStackTrace_(new Error('thenAlways'));\\n  }\\n\\n  var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);\\n  entry.always = true;\\n  this.addCallbackEntry_(entry);\\n  return this;\\n};\\n\\n\\n/**\\n * Adds a callback that will be invoked only if the Promise is rejected. This\\n * is equivalent to `then(null, onRejected)`.\\n *\\n * @param {function(this:THIS, *): *} onRejected A function that will be\\n *     invoked with the rejection reason if this Promise is rejected.\\n * @param {THIS=} opt_context An optional context object that will be the\\n *     execution context for the callbacks. By default, functions are executed\\n *     in the global scope.\\n * @return {!goog.Promise} A new Promise that will resolve either to the\\n *     value of this promise, or if this promise is rejected, the result of\\n *     `onRejected`. The returned Promise will reject if `onRejected` throws.\\n * @template THIS\\n */\\ngoog.Promise.prototype.thenCatch = function(onRejected, opt_context) {\\n  if (goog.Promise.LONG_STACK_TRACES) {\\n    this.addStackTrace_(new Error('thenCatch'));\\n  }\\n  return this.addChildPromise_(null, onRejected, opt_context);\\n};\\n\\n\\n/**\\n * Cancels the Promise if it is still pending by rejecting it with a cancel\\n * Error. No action is performed if the Promise is already resolved.\\n *\\n * All child Promises of the canceled Promise will be rejected with the same\\n * cancel error, as with normal Promise rejection. If the Promise to be canceled\\n * is the only child of a pending Promise, the parent Promise will also be\\n * canceled. Cancellation may propagate upward through multiple generations.\\n *\\n * @param {string=} opt_message An optional debugging message for describing the\\n *     cancellation reason.\\n */\\ngoog.Promise.prototype.cancel = function(opt_message) {\\n  if (this.state_ == goog.Promise.State_.PENDING) {\\n    // Instantiate Error object synchronously. This ensures Error::stack points\\n    // to the cancel() callsite.\\n    var err = new goog.Promise.CancellationError(opt_message);\\n    goog.async.run(function() {\\n      this.cancelInternal_(err);\\n    }, this);\\n  }\\n};\\n\\n\\n/**\\n * Cancels this Promise with the given error.\\n *\\n * @param {!Error} err The cancellation error.\\n * @private\\n */\\ngoog.Promise.prototype.cancelInternal_ = function(err) {\\n  if (this.state_ == goog.Promise.State_.PENDING) {\\n    if (this.parent_) {\\n      // Cancel the Promise and remove it from the parent's child list.\\n      this.parent_.cancelChild_(this, err);\\n      this.parent_ = null;\\n    } else {\\n      this.resolve_(goog.Promise.State_.REJECTED, err);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Cancels a child Promise from the list of callback entries. If the Promise has\\n * not already been resolved, reject it with a cancel error. If there are no\\n * other children in the list of callback entries, propagate the cancellation\\n * by canceling this Promise as well.\\n *\\n * @param {!goog.Promise} childPromise The Promise to cancel.\\n * @param {!Error} err The cancel error to use for rejecting the Promise.\\n * @private\\n */\\ngoog.Promise.prototype.cancelChild_ = function(childPromise, err) {\\n  if (!this.callbackEntries_) {\\n    return;\\n  }\\n  var childCount = 0;\\n  var childEntry = null;\\n  var beforeChildEntry = null;\\n\\n  // Find the callback entry for the childPromise, and count whether there are\\n  // additional child Promises.\\n  for (var entry = this.callbackEntries_; entry; entry = entry.next) {\\n    if (!entry.always) {\\n      childCount++;\\n      if (entry.child == childPromise) {\\n        childEntry = entry;\\n      }\\n      if (childEntry && childCount > 1) {\\n        break;\\n      }\\n    }\\n    if (!childEntry) {\\n      beforeChildEntry = entry;\\n    }\\n  }\\n\\n  // Can a child entry be missing?\\n\\n  // If the child Promise was the only child, cancel this Promise as well.\\n  // Otherwise, reject only the child Promise with the cancel error.\\n  if (childEntry) {\\n    if (this.state_ == goog.Promise.State_.PENDING && childCount == 1) {\\n      this.cancelInternal_(err);\\n    } else {\\n      if (beforeChildEntry) {\\n        this.removeEntryAfter_(beforeChildEntry);\\n      } else {\\n        this.popEntry_();\\n      }\\n\\n      this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err);\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Adds a callback entry to the current Promise, and schedules callback\\n * execution if the Promise has already been settled.\\n *\\n * @param {goog.Promise.CallbackEntry_} callbackEntry Record containing\\n *     `onFulfilled` and `onRejected` callbacks to execute after\\n *     the Promise is settled.\\n * @private\\n */\\ngoog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {\\n  if (!this.hasEntry_() && (this.state_ == goog.Promise.State_.FULFILLED ||\\n                            this.state_ == goog.Promise.State_.REJECTED)) {\\n    this.scheduleCallbacks_();\\n  }\\n  this.queueEntry_(callbackEntry);\\n};\\n\\n\\n/**\\n * Creates a child Promise and adds it to the callback entry list. The result of\\n * the child Promise is determined by the state of the parent Promise and the\\n * result of the `onFulfilled` or `onRejected` callbacks as\\n * specified in the Promise resolution procedure.\\n *\\n * @see http://promisesaplus.com/#the__method\\n *\\n * @param {?function(this:THIS, TYPE):\\n *          (RESULT|goog.Promise<RESULT>|Thenable)} onFulfilled A callback that\\n *     will be invoked if the Promise is fulfilled, or null.\\n * @param {?function(this:THIS, *): *} onRejected A callback that will be\\n *     invoked if the Promise is rejected, or null.\\n * @param {THIS=} opt_context An optional execution context for the callbacks.\\n *     in the default calling context.\\n * @return {!goog.Promise} The child Promise.\\n * @template RESULT,THIS\\n * @private\\n */\\ngoog.Promise.prototype.addChildPromise_ = function(\\n    onFulfilled, onRejected, opt_context) {\\n\\n  /** @type {goog.Promise.CallbackEntry_} */\\n  var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);\\n\\n  callbackEntry.child = new goog.Promise(function(resolve, reject) {\\n    // Invoke onFulfilled, or resolve with the parent's value if absent.\\n    callbackEntry.onFulfilled = onFulfilled ? function(value) {\\n      try {\\n        var result = onFulfilled.call(opt_context, value);\\n        resolve(result);\\n      } catch (err) {\\n        reject(err);\\n      }\\n    } : resolve;\\n\\n    // Invoke onRejected, or reject with the parent's reason if absent.\\n    callbackEntry.onRejected = onRejected ? function(reason) {\\n      try {\\n        var result = onRejected.call(opt_context, reason);\\n        if (result === undefined &&\\n            reason instanceof goog.Promise.CancellationError) {\\n          // Propagate cancellation to children if no other result is returned.\\n          reject(reason);\\n        } else {\\n          resolve(result);\\n        }\\n      } catch (err) {\\n        reject(err);\\n      }\\n    } : reject;\\n  });\\n\\n  callbackEntry.child.parent_ = this;\\n  this.addCallbackEntry_(callbackEntry);\\n  return callbackEntry.child;\\n};\\n\\n\\n/**\\n * Unblocks the Promise and fulfills it with the given value.\\n *\\n * @param {TYPE} value\\n * @private\\n */\\ngoog.Promise.prototype.unblockAndFulfill_ = function(value) {\\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\\n  this.state_ = goog.Promise.State_.PENDING;\\n  this.resolve_(goog.Promise.State_.FULFILLED, value);\\n};\\n\\n\\n/**\\n * Unblocks the Promise and rejects it with the given rejection reason.\\n *\\n * @param {*} reason\\n * @private\\n */\\ngoog.Promise.prototype.unblockAndReject_ = function(reason) {\\n  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);\\n  this.state_ = goog.Promise.State_.PENDING;\\n  this.resolve_(goog.Promise.State_.REJECTED, reason);\\n};\\n\\n\\n/**\\n * Attempts to resolve a Promise with a given resolution state and value. This\\n * is a no-op if the given Promise has already been resolved.\\n *\\n * If the given result is a Thenable (such as another Promise), the Promise will\\n * be settled with the same state and result as the Thenable once it is itself\\n * settled.\\n *\\n * If the given result is not a Thenable, the Promise will be settled (fulfilled\\n * or rejected) with that result based on the given state.\\n *\\n * @see http://promisesaplus.com/#the_promise_resolution_procedure\\n *\\n * @param {goog.Promise.State_} state\\n * @param {*} x The result to apply to the Promise.\\n * @private\\n */\\ngoog.Promise.prototype.resolve_ = function(state, x) {\\n  if (this.state_ != goog.Promise.State_.PENDING) {\\n    return;\\n  }\\n\\n  if (this === x) {\\n    state = goog.Promise.State_.REJECTED;\\n    x = new TypeError('Promise cannot resolve to itself');\\n  }\\n\\n  this.state_ = goog.Promise.State_.BLOCKED;\\n  var isThenable = goog.Promise.maybeThen_(\\n      x, this.unblockAndFulfill_, this.unblockAndReject_, this);\\n  if (isThenable) {\\n    return;\\n  }\\n\\n  this.result_ = x;\\n  this.state_ = state;\\n  // Since we can no longer be canceled, remove link to parent, so that the\\n  // child promise does not keep the parent promise alive.\\n  this.parent_ = null;\\n  this.scheduleCallbacks_();\\n\\n  if (state == goog.Promise.State_.REJECTED &&\\n      !(x instanceof goog.Promise.CancellationError)) {\\n    goog.Promise.addUnhandledRejection_(this, x);\\n  }\\n};\\n\\n\\n/**\\n * Invokes the \\\"then\\\" method of an input value if that value is a Thenable. This\\n * is a no-op if the value is not thenable.\\n *\\n * @param {?} value A potentially thenable value.\\n * @param {!Function} onFulfilled\\n * @param {!Function} onRejected\\n * @param {?} context\\n * @return {boolean} Whether the input value was thenable.\\n * @private\\n */\\ngoog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {\\n  if (value instanceof goog.Promise) {\\n    value.thenVoid(onFulfilled, onRejected, context);\\n    return true;\\n  } else if (goog.Thenable.isImplementedBy(value)) {\\n    value = /** @type {!goog.Thenable} */ (value);\\n    value.then(onFulfilled, onRejected, context);\\n    return true;\\n  } else if (goog.isObject(value)) {\\n    try {\\n      var then = value['then'];\\n      if (goog.isFunction(then)) {\\n        goog.Promise.tryThen_(value, then, onFulfilled, onRejected, context);\\n        return true;\\n      }\\n    } catch (e) {\\n      onRejected.call(context, e);\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n\\n\\n/**\\n * Attempts to call the `then` method on an object in the hopes that it is\\n * a Promise-compatible instance. This allows interoperation between different\\n * Promise implementations, however a non-compliant object may cause a Promise\\n * to hang indefinitely. If the `then` method throws an exception, the\\n * dependent Promise will be rejected with the thrown value.\\n *\\n * @see http://promisesaplus.com/#point-70\\n *\\n * @param {Thenable} thenable An object with a `then` method that may be\\n *     compatible with the Promise/A+ specification.\\n * @param {!Function} then The `then` method of the Thenable object.\\n * @param {!Function} onFulfilled\\n * @param {!Function} onRejected\\n * @param {*} context\\n * @private\\n */\\ngoog.Promise.tryThen_ = function(\\n    thenable, then, onFulfilled, onRejected, context) {\\n\\n  var called = false;\\n  var resolve = function(value) {\\n    if (!called) {\\n      called = true;\\n      onFulfilled.call(context, value);\\n    }\\n  };\\n\\n  var reject = function(reason) {\\n    if (!called) {\\n      called = true;\\n      onRejected.call(context, reason);\\n    }\\n  };\\n\\n  try {\\n    then.call(thenable, resolve, reject);\\n  } catch (e) {\\n    reject(e);\\n  }\\n};\\n\\n\\n/**\\n * Executes the pending callbacks of a settled Promise after a timeout.\\n *\\n * Section 2.2.4 of the Promises/A+ specification requires that Promise\\n * callbacks must only be invoked from a call stack that only contains Promise\\n * implementation code, which we accomplish by invoking callback execution after\\n * a timeout. If `startExecution_` is called multiple times for the same\\n * Promise, the callback chain will be evaluated only once. Additional callbacks\\n * may be added during the evaluation phase, and will be executed in the same\\n * event loop.\\n *\\n * All Promises added to the waiting list during the same browser event loop\\n * will be executed in one batch to avoid using a separate timeout per Promise.\\n *\\n * @private\\n */\\ngoog.Promise.prototype.scheduleCallbacks_ = function() {\\n  if (!this.executing_) {\\n    this.executing_ = true;\\n    goog.async.run(this.executeCallbacks_, this);\\n  }\\n};\\n\\n\\n/**\\n * @return {boolean} Whether there are any pending callbacks queued.\\n * @private\\n */\\ngoog.Promise.prototype.hasEntry_ = function() {\\n  return !!this.callbackEntries_;\\n};\\n\\n\\n/**\\n * @param {goog.Promise.CallbackEntry_} entry\\n * @private\\n */\\ngoog.Promise.prototype.queueEntry_ = function(entry) {\\n  goog.asserts.assert(entry.onFulfilled != null);\\n\\n  if (this.callbackEntriesTail_) {\\n    this.callbackEntriesTail_.next = entry;\\n    this.callbackEntriesTail_ = entry;\\n  } else {\\n    // It the work queue was empty set the head too.\\n    this.callbackEntries_ = entry;\\n    this.callbackEntriesTail_ = entry;\\n  }\\n};\\n\\n\\n/**\\n * @return {goog.Promise.CallbackEntry_} entry\\n * @private\\n */\\ngoog.Promise.prototype.popEntry_ = function() {\\n  var entry = null;\\n  if (this.callbackEntries_) {\\n    entry = this.callbackEntries_;\\n    this.callbackEntries_ = entry.next;\\n    entry.next = null;\\n  }\\n  // It the work queue is empty clear the tail too.\\n  if (!this.callbackEntries_) {\\n    this.callbackEntriesTail_ = null;\\n  }\\n\\n  if (entry != null) {\\n    goog.asserts.assert(entry.onFulfilled != null);\\n  }\\n  return entry;\\n};\\n\\n\\n/**\\n * @param {goog.Promise.CallbackEntry_} previous\\n * @private\\n */\\ngoog.Promise.prototype.removeEntryAfter_ = function(previous) {\\n  goog.asserts.assert(this.callbackEntries_);\\n  goog.asserts.assert(previous != null);\\n  // If the last entry is being removed, update the tail\\n  if (previous.next == this.callbackEntriesTail_) {\\n    this.callbackEntriesTail_ = previous;\\n  }\\n\\n  previous.next = previous.next.next;\\n};\\n\\n\\n/**\\n * Executes all pending callbacks for this Promise.\\n *\\n * @private\\n */\\ngoog.Promise.prototype.executeCallbacks_ = function() {\\n  var entry = null;\\n  while (entry = this.popEntry_()) {\\n    if (goog.Promise.LONG_STACK_TRACES) {\\n      this.currentStep_++;\\n    }\\n    this.executeCallback_(entry, this.state_, this.result_);\\n  }\\n  this.executing_ = false;\\n};\\n\\n\\n/**\\n * Executes a pending callback for this Promise. Invokes an `onFulfilled`\\n * or `onRejected` callback based on the settled state of the Promise.\\n *\\n * @param {!goog.Promise.CallbackEntry_} callbackEntry An entry containing the\\n *     onFulfilled and/or onRejected callbacks for this step.\\n * @param {goog.Promise.State_} state The resolution status of the Promise,\\n *     either FULFILLED or REJECTED.\\n * @param {*} result The settled result of the Promise.\\n * @private\\n */\\ngoog.Promise.prototype.executeCallback_ = function(\\n    callbackEntry, state, result) {\\n  // Cancel an unhandled rejection if the then/thenVoid call had an onRejected.\\n  if (state == goog.Promise.State_.REJECTED && callbackEntry.onRejected &&\\n      !callbackEntry.always) {\\n    this.removeUnhandledRejection_();\\n  }\\n\\n  if (callbackEntry.child) {\\n    // When the parent is settled, the child no longer needs to hold on to it,\\n    // as the parent can no longer be canceled.\\n    callbackEntry.child.parent_ = null;\\n    goog.Promise.invokeCallback_(callbackEntry, state, result);\\n  } else {\\n    // Callbacks created with thenAlways or thenVoid do not have the rejection\\n    // handling code normally set up in the child Promise.\\n    try {\\n      callbackEntry.always ?\\n          callbackEntry.onFulfilled.call(callbackEntry.context) :\\n          goog.Promise.invokeCallback_(callbackEntry, state, result);\\n    } catch (err) {\\n      goog.Promise.handleRejection_.call(null, err);\\n    }\\n  }\\n  goog.Promise.returnEntry_(callbackEntry);\\n};\\n\\n\\n/**\\n * Executes the onFulfilled or onRejected callback for a callbackEntry.\\n *\\n * @param {!goog.Promise.CallbackEntry_} callbackEntry\\n * @param {goog.Promise.State_} state\\n * @param {*} result\\n * @private\\n */\\ngoog.Promise.invokeCallback_ = function(callbackEntry, state, result) {\\n  if (state == goog.Promise.State_.FULFILLED) {\\n    callbackEntry.onFulfilled.call(callbackEntry.context, result);\\n  } else if (callbackEntry.onRejected) {\\n    callbackEntry.onRejected.call(callbackEntry.context, result);\\n  }\\n};\\n\\n\\n/**\\n * Records a stack trace entry for functions that call `then` or the\\n * Promise constructor. May be disabled by unsetting `LONG_STACK_TRACES`.\\n *\\n * @param {!Error} err An Error object created by the calling function for\\n *     providing a stack trace.\\n * @private\\n */\\ngoog.Promise.prototype.addStackTrace_ = function(err) {\\n  if (goog.Promise.LONG_STACK_TRACES && typeof err.stack === 'string') {\\n    // Extract the third line of the stack trace, which is the entry for the\\n    // user function that called into Promise code.\\n    var trace = err.stack.split('\\\\n', 4)[3];\\n    var message = err.message;\\n\\n    // Pad the message to align the traces.\\n    message += Array(11 - message.length).join(' ');\\n    this.stack_.push(message + trace);\\n  }\\n};\\n\\n\\n/**\\n * Adds extra stack trace information to an exception for the list of\\n * asynchronous `then` calls that have been run for this Promise. Stack\\n * trace information is recorded in {@see #addStackTrace_}, and appended to\\n * rethrown errors when `LONG_STACK_TRACES` is enabled.\\n *\\n * @param {?} err An unhandled exception captured during callback execution.\\n * @private\\n */\\ngoog.Promise.prototype.appendLongStack_ = function(err) {\\n  if (goog.Promise.LONG_STACK_TRACES && err && typeof err.stack === 'string' &&\\n      this.stack_.length) {\\n    var longTrace = ['Promise trace:'];\\n\\n    for (var promise = this; promise; promise = promise.parent_) {\\n      for (var i = this.currentStep_; i >= 0; i--) {\\n        longTrace.push(promise.stack_[i]);\\n      }\\n      longTrace.push(\\n          'Value: ' +\\n          '[' + (promise.state_ == goog.Promise.State_.REJECTED ? 'REJECTED' :\\n                                                                  'FULFILLED') +\\n          '] ' +\\n          '<' + String(promise.result_) + '>');\\n    }\\n    err.stack += '\\\\n\\\\n' + longTrace.join('\\\\n');\\n  }\\n};\\n\\n\\n/**\\n * Marks this rejected Promise as having being handled. Also marks any parent\\n * Promises in the rejected state as handled. The rejection handler will no\\n * longer be invoked for this Promise (if it has not been called already).\\n *\\n * @private\\n */\\ngoog.Promise.prototype.removeUnhandledRejection_ = function() {\\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\\n    for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {\\n      goog.global.clearTimeout(p.unhandledRejectionId_);\\n      p.unhandledRejectionId_ = 0;\\n    }\\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\\n    for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) {\\n      p.hadUnhandledRejection_ = false;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * Marks this rejected Promise as unhandled. If no `onRejected` callback\\n * is called for this Promise before the `UNHANDLED_REJECTION_DELAY`\\n * expires, the reason will be passed to the unhandled rejection handler. The\\n * handler typically rethrows the rejection reason so that it becomes visible in\\n * the developer console.\\n *\\n * @param {!goog.Promise} promise The rejected Promise.\\n * @param {*} reason The Promise rejection reason.\\n * @private\\n */\\ngoog.Promise.addUnhandledRejection_ = function(promise, reason) {\\n  if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) {\\n    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {\\n      promise.appendLongStack_(reason);\\n      goog.Promise.handleRejection_.call(null, reason);\\n    }, goog.Promise.UNHANDLED_REJECTION_DELAY);\\n\\n  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {\\n    promise.hadUnhandledRejection_ = true;\\n    goog.async.run(function() {\\n      if (promise.hadUnhandledRejection_) {\\n        promise.appendLongStack_(reason);\\n        goog.Promise.handleRejection_.call(null, reason);\\n      }\\n    });\\n  }\\n};\\n\\n\\n/**\\n * A method that is invoked with the rejection reasons for Promises that are\\n * rejected but have no `onRejected` callbacks registered yet.\\n * @type {function(*)}\\n * @private\\n */\\ngoog.Promise.handleRejection_ = goog.async.throwException;\\n\\n\\n/**\\n * Sets a handler that will be called with reasons from unhandled rejected\\n * Promises. If the rejected Promise (or one of its descendants) has an\\n * `onRejected` callback registered, the rejection will be considered\\n * handled, and the rejection handler will not be called.\\n *\\n * By default, unhandled rejections are rethrown so that the error may be\\n * captured by the developer console or a `window.onerror` handler.\\n *\\n * @param {function(*)} handler A function that will be called with reasons from\\n *     rejected Promises. Defaults to `goog.async.throwException`.\\n */\\ngoog.Promise.setUnhandledRejectionHandler = function(handler) {\\n  goog.Promise.handleRejection_ = handler;\\n};\\n\\n\\n\\n/**\\n * Error used as a rejection reason for canceled Promises.\\n *\\n * @param {string=} opt_message\\n * @constructor\\n * @extends {goog.debug.Error}\\n * @final\\n */\\ngoog.Promise.CancellationError = function(opt_message) {\\n  goog.Promise.CancellationError.base(this, 'constructor', opt_message);\\n};\\ngoog.inherits(goog.Promise.CancellationError, goog.debug.Error);\\n\\n\\n/** @override */\\ngoog.Promise.CancellationError.prototype.name = 'cancel';\\n\\n\\n\\n/**\\n * Internal implementation of the resolver interface.\\n *\\n * @param {!goog.Promise<TYPE>} promise\\n * @param {function((TYPE|goog.Promise<TYPE>|Thenable)=)} resolve\\n * @param {function(*=): void} reject\\n * @implements {goog.promise.Resolver<TYPE>}\\n * @final @struct\\n * @constructor\\n * @private\\n * @template TYPE\\n */\\ngoog.Promise.Resolver_ = function(promise, resolve, reject) {\\n  /** @const */\\n  this.promise = promise;\\n\\n  /** @const */\\n  this.resolve = resolve;\\n\\n  /** @const */\\n  this.reject = reject;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"Promise\",\"goog.Promise\",\"resolver\",\"opt_context\",\"state_\",\"State_\",\"PENDING\",\"result_\",\"undefined\",\"parent_\",\"callbackEntries_\",\"callbackEntriesTail_\",\"executing_\",\"UNHANDLED_REJECTION_DELAY\",\"unhandledRejectionId_\",\"hadUnhandledRejection_\",\"LONG_STACK_TRACES\",\"stack_\",\"addStackTrace_\",\"Error\",\"currentStep_\",\"nullFunction\",\"self\",\"call\",\"value\",\"resolve_\",\"FULFILLED\",\"reason\",\"DEBUG\",\"CancellationError\",\"e\",\"REJECTED\",\"define\",\"BLOCKED\",\"CallbackEntry_\",\"goog.Promise.CallbackEntry_\",\"child\",\"onFulfilled\",\"onRejected\",\"context\",\"next\",\"always\",\"prototype\",\"reset\",\"goog.Promise.CallbackEntry_.prototype.reset\",\"DEFAULT_MAX_UNUSED\",\"freelist_\",\"async\",\"FreeList\",\"item\",\"getCallbackEntry_\",\"goog.Promise.getCallbackEntry_\",\"entry\",\"get\",\"returnEntry_\",\"goog.Promise.returnEntry_\",\"put\",\"resolve\",\"goog.Promise.resolve\",\"opt_value\",\"promise\",\"reject\",\"goog.Promise.reject\",\"opt_reason\",\"resolveThen_\",\"goog.Promise.resolveThen_\",\"isThenable\",\"maybeThen_\",\"run\",\"partial\",\"race\",\"goog.Promise.race\",\"promises\",\"length\",\"i\",\"all\",\"goog.Promise.all\",\"toFulfill\",\"values\",\"onFulfill\",\"index\",\"onReject\",\"allSettled\",\"goog.Promise.allSettled\",\"toSettle\",\"results\",\"onSettled\",\"fulfilled\",\"result\",\"firstFulfilled\",\"goog.Promise.firstFulfilled\",\"toReject\",\"reasons\",\"withResolver\",\"goog.Promise.withResolver\",\"rs\",\"rj\",\"Resolver_\",\"then\",\"goog.Promise.prototype.then\",\"opt_onFulfilled\",\"opt_onRejected\",\"asserts\",\"assertFunction\",\"addChildPromise_\",\"isFunction\",\"Thenable\",\"addImplementation\",\"thenVoid\",\"goog.Promise.prototype.thenVoid\",\"addCallbackEntry_\",\"thenAlways\",\"goog.Promise.prototype.thenAlways\",\"thenCatch\",\"goog.Promise.prototype.thenCatch\",\"cancel\",\"goog.Promise.prototype.cancel\",\"opt_message\",\"err\",\"cancelInternal_\",\"goog.Promise.prototype.cancelInternal_\",\"cancelChild_\",\"goog.Promise.prototype.cancelChild_\",\"childPromise\",\"childCount\",\"childEntry\",\"beforeChildEntry\",\"removeEntryAfter_\",\"popEntry_\",\"executeCallback_\",\"goog.Promise.prototype.addCallbackEntry_\",\"callbackEntry\",\"hasEntry_\",\"scheduleCallbacks_\",\"queueEntry_\",\"goog.Promise.prototype.addChildPromise_\",\"unblockAndFulfill_\",\"goog.Promise.prototype.unblockAndFulfill_\",\"assert\",\"unblockAndReject_\",\"goog.Promise.prototype.unblockAndReject_\",\"goog.Promise.prototype.resolve_\",\"state\",\"x\",\"TypeError\",\"addUnhandledRejection_\",\"goog.Promise.maybeThen_\",\"isImplementedBy\",\"isObject\",\"tryThen_\",\"goog.Promise.tryThen_\",\"thenable\",\"called\",\"goog.Promise.prototype.scheduleCallbacks_\",\"executeCallbacks_\",\"goog.Promise.prototype.hasEntry_\",\"goog.Promise.prototype.queueEntry_\",\"goog.Promise.prototype.popEntry_\",\"goog.Promise.prototype.removeEntryAfter_\",\"previous\",\"goog.Promise.prototype.executeCallbacks_\",\"goog.Promise.prototype.executeCallback_\",\"removeUnhandledRejection_\",\"invokeCallback_\",\"handleRejection_\",\"goog.Promise.invokeCallback_\",\"goog.Promise.prototype.addStackTrace_\",\"stack\",\"trace\",\"split\",\"message\",\"Array\",\"join\",\"push\",\"appendLongStack_\",\"goog.Promise.prototype.appendLongStack_\",\"longTrace\",\"String\",\"goog.Promise.prototype.removeUnhandledRejection_\",\"p\",\"global\",\"clearTimeout\",\"goog.Promise.addUnhandledRejection_\",\"setTimeout\",\"throwException\",\"setUnhandledRejectionHandler\",\"goog.Promise.setUnhandledRejectionHandler\",\"handler\",\"goog.Promise.CancellationError\",\"base\",\"inherits\",\"debug\",\"name\",\"goog.Promise.Resolver_\"]\n}\n"]